import { abort } from 'env';


  var scratchBuffer = new ArrayBuffer(16);
  var i32ScratchView = new Int32Array(scratchBuffer);
  var f32ScratchView = new Float32Array(scratchBuffer);
  var f64ScratchView = new Float64Array(scratchBuffer);
  
  function wasm2js_scratch_load_i32(index) {
    return i32ScratchView[index];
  }
      
  function wasm2js_scratch_store_i32(index, value) {
    i32ScratchView[index] = value;
  }
      
  function wasm2js_scratch_load_f64() {
    return f64ScratchView[0];
  }
      
  function wasm2js_scratch_store_f64(value) {
    f64ScratchView[0] = value;
  }
      
function asmFunc(global, env, buffer) {
 var HEAP8 = new global.Int8Array(buffer);
 var HEAP16 = new global.Int16Array(buffer);
 var HEAP32 = new global.Int32Array(buffer);
 var HEAPU8 = new global.Uint8Array(buffer);
 var HEAPU16 = new global.Uint16Array(buffer);
 var HEAPU32 = new global.Uint32Array(buffer);
 var HEAPF32 = new global.Float32Array(buffer);
 var HEAPF64 = new global.Float64Array(buffer);
 var Math_imul = global.Math.imul;
 var Math_fround = global.Math.fround;
 var Math_abs = global.Math.abs;
 var Math_clz32 = global.Math.clz32;
 var Math_min = global.Math.min;
 var Math_max = global.Math.max;
 var Math_floor = global.Math.floor;
 var Math_ceil = global.Math.ceil;
 var Math_sqrt = global.Math.sqrt;
 var abort = env.abort;
 var nan = global.NaN;
 var infinity = global.Infinity;
 var $lib_builtins_abort = env.abort;
 var $lib_rt_tlsf_ROOT = 0;
 var index_INPUT_BUFFER_OFFSET = 5;
 var index_OUTPUT_BUFFER_OFFSET = 6;
 var index_input = 0;
 var index_output = 0;
 var $lib_math_rempio2_y0 = 0.0;
 var $lib_math_rempio2_y1 = 0.0;
 var $lib_math_res128_hi = 0;
 var $argumentsLength = 0;
 var $lib_rt___rtti_base = 1600;
 var $lib_math_res128_hi$hi = 0;
 var i64toi32_i32$HIGH_BITS = 0;
 function $lib_rt_tlsf_removeBlock($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0;
  $2 = HEAP32[$1 >> 2] & -4 | 0;
  if ($2 >>> 0 < 256 >>> 0) {
   $4 = $2 >>> 4 | 0
  } else {
   $3 = $2;
   $2 = 31 - Math_clz32($2) | 0;
   $4 = ($3 >>> ($2 - 4 | 0) | 0) ^ 16 | 0;
   $5 = $2 - 7 | 0;
  }
  $2 = HEAP32[($1 + 20 | 0) >> 2];
  $3 = HEAP32[($1 + 16 | 0) >> 2];
  if ($3) {
   HEAP32[($3 + 20 | 0) >> 2] = $2
  }
  if ($2) {
   HEAP32[($2 + 16 | 0) >> 2] = $3
  }
  if ((HEAP32[((((($5 << 4 | 0) + $4 | 0) << 2 | 0) + $0 | 0) + 96 | 0) >> 2] | 0) == ($1 | 0)) {
   HEAP32[((((($5 << 4 | 0) + $4 | 0) << 2 | 0) + $0 | 0) + 96 | 0) >> 2] = $2;
   if (!$2) {
    $2 = ($5 << 2 | 0) + $0 | 0;
    $1 = HEAP32[($2 + 4 | 0) >> 2] & ((1 << $4 | 0) ^ -1 | 0) | 0;
    HEAP32[($2 + 4 | 0) >> 2] = $1;
    if (!$1) {
     HEAP32[$0 >> 2] = HEAP32[$0 >> 2] & ((1 << $5 | 0) ^ -1 | 0) | 0
    }
   }
  }
 }
 
 function $lib_rt_tlsf_insertBlock($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0;
  $2 = HEAP32[$1 >> 2];
  $4 = ($1 + 16 | 0) + ($2 & -4 | 0) | 0;
  $5 = HEAP32[$4 >> 2];
  if ($5 & 1 | 0) {
   $3 = (($2 & -4 | 0) + 16 | 0) + ($5 & -4 | 0) | 0;
   if ($3 >>> 0 < 1073741808 >>> 0) {
    $lib_rt_tlsf_removeBlock($0, $4);
    $2 = $3 | ($2 & 3 | 0) | 0;
    HEAP32[$1 >> 2] = $2;
    $4 = ($1 + 16 | 0) + (HEAP32[$1 >> 2] & -4 | 0) | 0;
    $5 = HEAP32[$4 >> 2];
   }
  }
  if ($2 & 2 | 0) {
   $3 = HEAP32[($1 - 4 | 0) >> 2];
   $7 = HEAP32[$3 >> 2];
   $8 = (($7 & -4 | 0) + 16 | 0) + ($2 & -4 | 0) | 0;
   if ($8 >>> 0 < 1073741808 >>> 0) {
    $lib_rt_tlsf_removeBlock($0, $3);
    $2 = $7 & 3 | 0 | $8 | 0;
    HEAP32[$3 >> 2] = $2;
    $1 = $3;
   }
  }
  HEAP32[$4 >> 2] = $5 | 2 | 0;
  HEAP32[($4 - 4 | 0) >> 2] = $1;
  $3 = $2 & -4 | 0;
  if ($3 >>> 0 < 256 >>> 0) {
   $3 = $3 >>> 4 | 0
  } else {
   $2 = 31 - Math_clz32($3) | 0;
   $3 = ($3 >>> ($2 - 4 | 0) | 0) ^ 16 | 0;
   $6 = $2 - 7 | 0;
  }
  $2 = HEAP32[((((($6 << 4 | 0) + $3 | 0) << 2 | 0) + $0 | 0) + 96 | 0) >> 2];
  HEAP32[($1 + 16 | 0) >> 2] = 0;
  HEAP32[($1 + 20 | 0) >> 2] = $2;
  if ($2) {
   HEAP32[($2 + 16 | 0) >> 2] = $1
  }
  HEAP32[((((($6 << 4 | 0) + $3 | 0) << 2 | 0) + $0 | 0) + 96 | 0) >> 2] = $1;
  HEAP32[$0 >> 2] = HEAP32[$0 >> 2] | (1 << $6 | 0) | 0;
  $0 = ($6 << 2 | 0) + $0 | 0;
  $1 = HEAP32[($0 + 4 | 0) >> 2] | (1 << $3 | 0) | 0;
  HEAP32[($0 + 4 | 0) >> 2] = $1;
 }
 
 function $lib_rt_tlsf_addMemory($0, $1, $2) {
  var $3 = 0, $4 = 0;
  $3 = $2;
  $2 = HEAP32[($0 + 1568 | 0) >> 2];
  if ($2) {
   if (($2 | 0) == ($1 - 16 | 0 | 0)) {
    $4 = HEAP32[$2 >> 2];
    $1 = $1 - 16 | 0;
   }
  }
  $2 = $3 - $1 | 0;
  if ($2 >>> 0 < 48 >>> 0) {
   return
  }
  HEAP32[$1 >> 2] = $4 & 2 | 0 | ($2 - 32 | 0 | 1 | 0) | 0;
  HEAP32[($1 + 16 | 0) >> 2] = 0;
  HEAP32[($1 + 20 | 0) >> 2] = 0;
  $2 = ($1 + $2 | 0) - 16 | 0;
  HEAP32[$2 >> 2] = 2;
  HEAP32[($0 + 1568 | 0) >> 2] = $2;
  $lib_rt_tlsf_insertBlock($0, $1);
 }
 
 function $lib_rt_tlsf_maybeInitialize() {
  var $0 = 0, $1 = 0, $2 = 0;
  $2 = $lib_rt_tlsf_ROOT;
  if (!$2) {
   $0 = __wasm_memory_size();
   if ((1 | 0) > ($0 | 0)) {
    $0 = (__wasm_memory_grow(1 - $0 | 0 | 0) | 0) < (0 | 0)
   } else {
    $0 = 0
   }
   if ($0) {
    abort()
   }
   $2 = 1648;
   HEAP32[1648 >> 2] = 0;
   HEAP32[3216 >> 2] = 0;
   for_loop_0 : while (1) {
    if ($1 >>> 0 < 23 >>> 0) {
     HEAP32[((($1 << 2 | 0) + 1648 | 0) + 4 | 0) >> 2] = 0;
     $0 = 0;
     for_loop_1 : while (1) {
      if ($0 >>> 0 < 16 >>> 0) {
       HEAP32[((((($1 << 4 | 0) + $0 | 0) << 2 | 0) + 1648 | 0) + 96 | 0) >> 2] = 0;
       $0 = $0 + 1 | 0;
       continue for_loop_1;
      }
      break for_loop_1;
     };
     $1 = $1 + 1 | 0;
     continue for_loop_0;
    }
    break for_loop_0;
   };
   $lib_rt_tlsf_addMemory(1648, 3232, __wasm_memory_size() << 16 | 0);
   $lib_rt_tlsf_ROOT = 1648;
  }
  return $2;
 }
 
 function $lib_rt_tlsf_searchBlock($0, $1) {
  var $2 = 0;
  if ($1 >>> 0 < 256 >>> 0) {
   $1 = $1 >>> 4 | 0
  } else {
   if ($1 >>> 0 < 536870904 >>> 0) {
    $1 = ((1 << (27 - Math_clz32($1) | 0) | 0) + $1 | 0) - 1 | 0
   }
   $2 = 31 - Math_clz32($1) | 0;
   $1 = ($1 >>> ($2 - 4 | 0) | 0) ^ 16 | 0;
   $2 = $2 - 7 | 0;
  }
  $1 = HEAP32[((($2 << 2 | 0) + $0 | 0) + 4 | 0) >> 2] & (-1 << $1 | 0) | 0;
  if ($1) {
   if ($1) {
    $1 = 31 - Math_clz32(($1 + -1 | 0) ^ $1 | 0) | 0
   } else {
    $1 = 32
   }
   $0 = HEAP32[(((($1 + ($2 << 4 | 0) | 0) << 2 | 0) + $0 | 0) + 96 | 0) >> 2];
  } else {
   $1 = HEAP32[$0 >> 2] & (-1 << ($2 + 1 | 0) | 0) | 0;
   if ($1) {
    if ($1) {
     $1 = 31 - Math_clz32(($1 + -1 | 0) ^ $1 | 0) | 0
    } else {
     $1 = 32
    }
    $2 = HEAP32[((($1 << 2 | 0) + $0 | 0) + 4 | 0) >> 2];
    __inlined_func$__wasm_ctz_i321 : {
     if ($2) {
      $2 = 31 - Math_clz32(($2 + -1 | 0) ^ $2 | 0) | 0;
      break __inlined_func$__wasm_ctz_i321;
     }
     $2 = 32;
    }
    $0 = HEAP32[(((($2 + ($1 << 4 | 0) | 0) << 2 | 0) + $0 | 0) + 96 | 0) >> 2];
   } else {
    $0 = 0
   }
  }
  return $0;
 }
 
 function $lib_rt_tlsf_allocateBlock($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  $4 = $1;
  if ($1 >>> 0 >= 1073741808 >>> 0) {
   $lib_builtins_abort(1040 | 0, 1104 | 0, 461 | 0, 30 | 0);
   abort();
  }
  $1 = ($4 + 15 | 0) & -16 | 0;
  $3 = $1 >>> 0 > 16 >>> 0;
  $1 = $3 ? $1 : 16;
  $3 = $lib_rt_tlsf_searchBlock($0, $1);
  if (!$3) {
   $3 = $lib_rt_tlsf_searchBlock($0, $1);
   if (!$3) {
    $5 = __wasm_memory_size();
    $6 = ($5 << 16 | 0) - 16 | 0;
    $7 = $5;
    if ($1 >>> 0 < 536870904 >>> 0) {
     $3 = $1 + ((1 << (27 - Math_clz32($1) | 0) | 0) - 1 | 0) | 0
    } else {
     $3 = $1
    }
    $3 = ((($3 + (16 << ((HEAP32[($0 + 1568 | 0) >> 2] | 0) != ($6 | 0)) | 0) | 0) + 65535 | 0) & -65536 | 0) >>> 16 | 0;
    $6 = ($7 | 0) > ($3 | 0);
    if ((__wasm_memory_grow(($6 ? $5 : $3) | 0) | 0) < (0 | 0)) {
     if ((__wasm_memory_grow($3 | 0) | 0) < (0 | 0)) {
      abort()
     }
    }
    $lib_rt_tlsf_addMemory($0, $5 << 16 | 0, __wasm_memory_size() << 16 | 0);
    $3 = $lib_rt_tlsf_searchBlock($0, $1);
   }
  }
  HEAP32[($3 + 4 | 0) >> 2] = 0;
  HEAP32[($3 + 8 | 0) >> 2] = $2;
  HEAP32[($3 + 12 | 0) >> 2] = $4;
  $lib_rt_tlsf_removeBlock($0, $3);
  $2 = HEAP32[$3 >> 2];
  $4 = ($2 & -4 | 0) - $1 | 0;
  if ($4 >>> 0 >= 32 >>> 0) {
   HEAP32[$3 >> 2] = $1 | ($2 & 2 | 0) | 0;
   $1 = $1 + ($3 + 16 | 0) | 0;
   HEAP32[$1 >> 2] = $4 - 16 | 0 | 1 | 0;
   $lib_rt_tlsf_insertBlock($0, $1);
  } else {
   HEAP32[$3 >> 2] = $2 & -2 | 0;
   $0 = ($3 + 16 | 0) + (HEAP32[$3 >> 2] & -4 | 0) | 0;
   $1 = HEAP32[$0 >> 2] & -3 | 0;
   HEAP32[$0 >> 2] = $1;
  }
  return $3;
 }
 
 function $lib_rt_tlsf___alloc($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  return $lib_rt_tlsf_allocateBlock($lib_rt_tlsf_maybeInitialize(), $0, $1) + 16 | 0 | 0;
 }
 
 function $lib_rt_pure___retain($0) {
  $0 = $0 | 0;
  var $1 = 0;
  if ($0 >>> 0 > 1644 >>> 0) {
   $1 = $0 - 16 | 0;
   HEAP32[($1 + 4 | 0) >> 2] = HEAP32[($1 + 4 | 0) >> 2] + 1 | 0;
  }
  return $0 | 0;
 }
 
 function $lib_rt_pure___release($0) {
  $0 = $0 | 0;
  if ($0 >>> 0 > 1644 >>> 0) {
   $lib_rt_pure_decrement($0 - 16 | 0)
  }
 }
 
 function $lib_memory_memory_fill($0, $1) {
  var $2 = 0;
  $lib_util_memory_memset_inlined_0 : {
   if (!$1) {
    break $lib_util_memory_memset_inlined_0
   }
   HEAP8[$0 >> 0] = 0;
   $2 = ($0 + $1 | 0) - 4 | 0;
   HEAP8[($2 + 3 | 0) >> 0] = 0;
   if ($1 >>> 0 <= 2 >>> 0) {
    break $lib_util_memory_memset_inlined_0
   }
   HEAP8[($0 + 1 | 0) >> 0] = 0;
   HEAP8[($0 + 2 | 0) >> 0] = 0;
   HEAP8[($2 + 2 | 0) >> 0] = 0;
   HEAP8[($2 + 1 | 0) >> 0] = 0;
   if ($1 >>> 0 <= 6 >>> 0) {
    break $lib_util_memory_memset_inlined_0
   }
   HEAP8[($0 + 3 | 0) >> 0] = 0;
   HEAP8[$2 >> 0] = 0;
   if ($1 >>> 0 <= 8 >>> 0) {
    break $lib_util_memory_memset_inlined_0
   }
   $2 = (0 - $0 | 0) & 3 | 0;
   $0 = $2 + $0 | 0;
   HEAP32[$0 >> 2] = 0;
   $2 = ($1 - $2 | 0) & -4 | 0;
   $1 = ($2 + $0 | 0) - 28 | 0;
   HEAP32[($1 + 24 | 0) >> 2] = 0;
   if ($2 >>> 0 <= 8 >>> 0) {
    break $lib_util_memory_memset_inlined_0
   }
   HEAP32[($0 + 4 | 0) >> 2] = 0;
   HEAP32[($0 + 8 | 0) >> 2] = 0;
   HEAP32[($1 + 16 | 0) >> 2] = 0;
   HEAP32[($1 + 20 | 0) >> 2] = 0;
   if ($2 >>> 0 <= 24 >>> 0) {
    break $lib_util_memory_memset_inlined_0
   }
   HEAP32[($0 + 12 | 0) >> 2] = 0;
   HEAP32[($0 + 16 | 0) >> 2] = 0;
   HEAP32[($0 + 20 | 0) >> 2] = 0;
   HEAP32[($0 + 24 | 0) >> 2] = 0;
   HEAP32[$1 >> 2] = 0;
   HEAP32[($1 + 4 | 0) >> 2] = 0;
   HEAP32[($1 + 8 | 0) >> 2] = 0;
   HEAP32[($1 + 12 | 0) >> 2] = 0;
   $1 = ($0 & 4 | 0) + 24 | 0;
   $0 = $1 + $0 | 0;
   $1 = $2 - $1 | 0;
   while_continue_0 : while (1) {
    if ($1 >>> 0 >= 32 >>> 0) {
     HEAP32[$0 >> 2] = 0;
     HEAP32[($0 + 4 | 0) >> 2] = 0;
     HEAP32[($0 + 8 | 0) >> 2] = 0;
     HEAP32[($0 + 12 | 0) >> 2] = 0;
     HEAP32[($0 + 16 | 0) >> 2] = 0;
     HEAP32[($0 + 20 | 0) >> 2] = 0;
     HEAP32[($0 + 24 | 0) >> 2] = 0;
     HEAP32[($0 + 28 | 0) >> 2] = 0;
     $1 = $1 - 32 | 0;
     $0 = $0 + 32 | 0;
     continue while_continue_0;
    }
    break while_continue_0;
   };
  }
 }
 
 function $lib_arraybuffer_ArrayBufferView_constructor($0) {
  var $1 = 0, $2 = 0, $3 = 0;
  if (!$0) {
   $0 = $lib_rt_tlsf_allocateBlock($lib_rt_tlsf_maybeInitialize(), 12, 2) + 16 | 0;
   if ($0 >>> 0 > 1644 >>> 0) {
    $1 = $0 - 16 | 0;
    $2 = HEAP32[($1 + 4 | 0) >> 2] + 1 | 0;
    HEAP32[($1 + 4 | 0) >> 2] = $2;
   }
  }
  HEAP32[$0 >> 2] = 0;
  HEAP32[($0 + 4 | 0) >> 2] = 0;
  HEAP32[($0 + 8 | 0) >> 2] = 0;
  $1 = $lib_rt_tlsf_allocateBlock($lib_rt_tlsf_maybeInitialize(), 160, 0) + 16 | 0;
  $lib_memory_memory_fill($1, 160);
  $2 = HEAP32[$0 >> 2];
  if (($1 | 0) != ($2 | 0)) {
   if ($1 >>> 0 > 1644 >>> 0) {
    $3 = $1 - 16 | 0;
    HEAP32[($3 + 4 | 0) >> 2] = HEAP32[($3 + 4 | 0) >> 2] + 1 | 0;
   }
   if ($2 >>> 0 > 1644 >>> 0) {
    $lib_rt_pure_decrement($2 - 16 | 0)
   }
  }
  HEAP32[$0 >> 2] = $1;
  HEAP32[($0 + 4 | 0) >> 2] = $1;
  HEAP32[($0 + 8 | 0) >> 2] = 160;
  return $0;
 }
 
 function $lib_typedarray_Float64Array_constructor() {
  var $0 = 0, $1 = 0;
  $0 = $lib_rt_tlsf_allocateBlock($lib_rt_tlsf_maybeInitialize(), 12, 3) + 16 | 0;
  if ($0 >>> 0 > 1644 >>> 0) {
   $1 = $0 - 16 | 0;
   HEAP32[($1 + 4 | 0) >> 2] = HEAP32[($1 + 4 | 0) >> 2] + 1 | 0;
  }
  return $lib_arraybuffer_ArrayBufferView_constructor($0);
 }
 
 function index_getInputBufferPtr() {
  var $0 = 0, $1 = 0;
  $0 = index_input;
  if ($0 >>> 0 > 1644 >>> 0) {
   $1 = $0 - 16 | 0;
   HEAP32[($1 + 4 | 0) >> 2] = HEAP32[($1 + 4 | 0) >> 2] + 1 | 0;
  }
  return $0 | 0;
 }
 
 function index_getOutputBufferPtr() {
  var $0 = 0, $1 = 0;
  $0 = index_output;
  if ($0 >>> 0 > 1644 >>> 0) {
   $1 = $0 - 16 | 0;
   HEAP32[($1 + 4 | 0) >> 2] = HEAP32[($1 + 4 | 0) >> 2] + 1 | 0;
  }
  return $0 | 0;
 }
 
 function index_SolveQuadric($0, $1) {
  var $2 = 0.0, $3 = 0, $4 = 0.0, $5 = 0.0;
  $3 = HEAP32[(index_input + 4 | 0) >> 2];
  $2 = HEAPF64[($3 + 8 | 0) >> 3];
  $4 = HEAPF64[$3 >> 3];
  $5 = $2 * $2 - 4.0 * $4 * HEAPF64[($3 + 16 | 0) >> 3];
  if (Math_abs($5) < 1.0e-09) {
   $2 = -$2 / (2.0 * $4);
   $1 = index_output;
   if ($0 >>> 0 >= (HEAP32[($1 + 8 | 0) >> 2] >>> 3 | 0) >>> 0) {
    $lib_builtins_abort(1264 | 0, 1328 | 0, 1315 | 0, 64 | 0);
    abort();
   }
   HEAPF64[(HEAP32[($1 + 4 | 0) >> 2] + ($0 << 3 | 0) | 0) >> 3] = $2;
   $0 = 1;
  } else {
   if ($5 < 0.0) {
    $0 = 0
   } else {
    $3 = index_output;
    $2 = -$2;
    $5 = Math_sqrt($5);
    $4 = .5 / $4;
    HEAPF64[(HEAP32[($3 + 4 | 0) >> 2] + ($0 << 3 | 0) | 0) >> 3] = ($2 + $5) * $4;
    HEAPF64[(HEAP32[($3 + 4 | 0) >> 2] + ($1 << 3 | 0) | 0) >> 3] = ($2 - $5) * $4;
    $0 = 2;
   }
  }
  return $0;
 }
 
 function $lib_math_NativeMath_cbrt($0) {
  var $1 = 0, $2 = 0.0, $3 = 0, $4 = 0.0;
  wasm2js_scratch_store_f64(+$0);
  $1 = wasm2js_scratch_load_i32(1 | 0) | 0;
  $3 = $1;
  wasm2js_scratch_load_i32(0 | 0) | 0;
  $1 = $1 & 2147483647 | 0;
  if ($1 >>> 0 >= 2146435072 >>> 0) {
   return $0 + $0
  }
  if ($1 >>> 0 < 1048576 >>> 0) {
   wasm2js_scratch_store_f64(+($0 * 18014398509481984.0));
   $1 = wasm2js_scratch_load_i32(1 | 0) | 0;
   $3 = $1;
   wasm2js_scratch_load_i32(0 | 0) | 0;
   $1 = $1 & 2147483647 | 0;
   if (!$1) {
    return $0
   }
   $1 = (($1 >>> 0) / (3 >>> 0) | 0) + 696219795 | 0;
  } else {
   $1 = (($1 >>> 0) / (3 >>> 0) | 0) + 715094163 | 0
  }
  wasm2js_scratch_store_i32(0 | 0, 0 | 0);
  wasm2js_scratch_store_i32(1 | 0, $1 | ($3 & -2147483648 | 0) | 0 | 0);
  $4 = +wasm2js_scratch_load_f64();
  $2 = $4 * $4 * ($4 / $0);
  wasm2js_scratch_store_f64(+($4 * (1.87595182427177 + $2 * (-1.8849797954337717 + $2 * 1.6214297201053545) + $2 * $2 * $2 * (-.758397934778766 + $2 * .14599619288661245))));
  $1 = wasm2js_scratch_load_i32(1 | 0) | 0;
  $3 = (wasm2js_scratch_load_i32(0 | 0) | 0) + -2147483648 | 0;
  if ($3 >>> 0 < -2147483648 >>> 0) {
   $1 = $1 + 1 | 0
  }
  wasm2js_scratch_store_i32(0 | 0, $3 & -1073741824 | 0 | 0);
  wasm2js_scratch_store_i32(1 | 0, $1 | 0);
  $2 = $0;
  $0 = +wasm2js_scratch_load_f64();
  $2 = $2 / ($0 * $0);
  return $0 + $0 * (($2 - $0) / (2.0 * $0 + $2));
 }
 
 function $lib_math_NativeMath_acos($0) {
  var $1 = 0.0, $2 = 0, $3 = 0.0, $4 = 0;
  wasm2js_scratch_store_f64(+$0);
  $2 = wasm2js_scratch_load_i32(1 | 0) | 0;
  wasm2js_scratch_load_i32(0 | 0) | 0;
  $4 = $2 & 2147483647 | 0;
  if ($4 >>> 0 >= 1072693248 >>> 0) {
   wasm2js_scratch_store_f64(+$0);
   wasm2js_scratch_load_i32(1 | 0) | 0;
   if (!(wasm2js_scratch_load_i32(0 | 0) | 0 | ($4 - 1072693248 | 0) | 0)) {
    if ($2 >>> 31 | 0) {
     return 3.141592653589793
    }
    return 0.0;
   }
   return 0.0 / ($0 - $0);
  }
  if ($4 >>> 0 < 1071644672 >>> 0) {
   if ($4 >>> 0 <= 1012924416 >>> 0) {
    return 1.5707963267948966
   }
   $1 = $0 * $0;
   $3 = 7.915349942898145e-04 + $1 * 3.479331075960212e-05;
   return 1.5707963267948966 - ($0 - (6.123233995736766e-17 - $0 * ($1 * (.16666666666666666 + $1 * (-.3255658186224009 + $1 * (.20121253213486293 + $1 * (-.04005553450067941 + $1 * $3)))) / (1.0 + $1 * (-2.403394911734414 + $1 * (2.0209457602335057 + $1 * (-.6882839716054533 + $1 * .07703815055590194)))))));
  }
  if ($2 >>> 31 | 0) {
   $0 = .5 + $0 * .5;
   $1 = 7.915349942898145e-04 + $0 * 3.479331075960212e-05;
   $1 = $0 * (.16666666666666666 + $0 * (-.3255658186224009 + $0 * (.20121253213486293 + $0 * (-.04005553450067941 + $0 * $1)))) / (1.0 + $0 * (-2.403394911734414 + $0 * (2.0209457602335057 + $0 * (-.6882839716054533 + $0 * .07703815055590194))));
   $0 = Math_sqrt($0);
   $1 = $1 * $0 - 6.123233995736766e-17;
   return 2.0 * (1.5707963267948966 - ($0 + $1));
  }
  $0 = .5 - $0 * .5;
  $3 = Math_sqrt($0);
  wasm2js_scratch_store_f64(+$3);
  $2 = wasm2js_scratch_load_i32(1 | 0) | 0;
  wasm2js_scratch_load_i32(0 | 0) | 0;
  wasm2js_scratch_store_i32(0 | 0, 0 | 0);
  wasm2js_scratch_store_i32(1 | 0, $2 | 0);
  $1 = +wasm2js_scratch_load_f64();
  return 2.0 * ($1 + ($0 * (.16666666666666666 + $0 * (-.3255658186224009 + $0 * (.20121253213486293 + $0 * (-.04005553450067941 + $0 * (7.915349942898145e-04 + $0 * 3.479331075960212e-05))))) / (1.0 + $0 * (-2.403394911734414 + $0 * (2.0209457602335057 + $0 * (-.6882839716054533 + $0 * .07703815055590194)))) * $3 + ($0 - $1 * $1) / ($3 + $1)));
 }
 
 function $lib_math_pio2_large_quot($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0.0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0.0;
  $6 = $0;
  $2 = $1 & 2147483647 | 0;
  $0 = $2 >> 20 | 0;
  $7 = $0 - 1045 | 0;
  $5 = ((((($2 >> 31 | 0) - ($0 >>> 0 < 1045 >>> 0) | 0) & 63 | 0) << 26 | 0 | ($7 >>> 6 | 0) | 0) << 3 | 0) + 1368 | 0;
  $14 = HEAP32[$5 >> 2];
  $18 = HEAP32[($5 + 4 | 0) >> 2];
  $11 = HEAP32[($5 + 8 | 0) >> 2];
  $3 = HEAP32[($5 + 12 | 0) >> 2];
  $8 = HEAP32[($5 + 16 | 0) >> 2];
  $12 = HEAP32[($5 + 20 | 0) >> 2];
  $10 = $7 & 63 | 0;
  if ($10) {
   $0 = $10 & 31 | 0;
   if (32 >>> 0 <= ($10 & 63 | 0) >>> 0) {
    $2 = $14 << $0 | 0
   } else {
    $9 = $14 << $0 | 0;
    $2 = ((1 << $0 | 0) - 1 | 0) & ($14 >>> (32 - $0 | 0) | 0) | 0 | ($18 << $0 | 0) | 0;
   }
   $4 = 64 - $10 | 0;
   $7 = $4 & 31 | 0;
   if (32 >>> 0 <= ($4 & 63 | 0) >>> 0) {
    $0 = 0;
    $7 = $3 >>> $7 | 0;
   } else {
    $0 = $3 >>> $7 | 0;
    $7 = (((1 << $7 | 0) - 1 | 0) & $3 | 0) << (32 - $7 | 0) | 0 | ($11 >>> $7 | 0) | 0;
   }
   $14 = $7 | $9 | 0;
   $18 = $0 | $2 | 0;
   $0 = $10 & 31 | 0;
   if (32 >>> 0 <= ($10 & 63 | 0) >>> 0) {
    $9 = 0;
    $2 = $11 << $0 | 0;
   } else {
    $9 = $11 << $0 | 0;
    $2 = ((1 << $0 | 0) - 1 | 0) & ($11 >>> (32 - $0 | 0) | 0) | 0 | ($3 << $0 | 0) | 0;
   }
   $7 = $4 & 31 | 0;
   if (32 >>> 0 <= ($4 & 63 | 0) >>> 0) {
    $0 = 0;
    $3 = $12 >>> $7 | 0;
   } else {
    $0 = $12 >>> $7 | 0;
    $3 = (((1 << $7 | 0) - 1 | 0) & $12 | 0) << (32 - $7 | 0) | 0 | ($8 >>> $7 | 0) | 0;
   }
   $11 = $3 | $9 | 0;
   $3 = $0 | $2 | 0;
   $0 = $10 & 31 | 0;
   if (32 >>> 0 <= ($10 & 63 | 0) >>> 0) {
    $0 = $8 << $0 | 0
   } else {
    $0 = ((1 << $0 | 0) - 1 | 0) & ($8 >>> (32 - $0 | 0) | 0) | 0 | ($12 << $0 | 0) | 0
   }
   $12 = $0 | (32 >>> 0 <= ($4 & 63 | 0) >>> 0 ? 0 : HEAP32[($5 + 28 | 0) >> 2] >>> ($4 & 31 | 0) | 0) | 0;
  }
  $0 = $11 & 65535 | 0;
  $8 = $6 & 65535 | 0;
  $7 = Math_imul($0, $8);
  $2 = $6 >>> 16 | 0;
  $4 = ($7 >>> 16 | 0) + Math_imul($0, $2) | 0;
  $0 = $11 >>> 16 | 0;
  $8 = Math_imul($8, $0) + ($4 & 65535 | 0) | 0;
  i64toi32_i32$HIGH_BITS = (Math_imul($0, $2) + ($4 >>> 16 | 0) | 0) + ($8 >>> 16 | 0) | 0;
  $7 = $7 & 65535 | 0 | ($8 << 16 | 0) | 0;
  $16 = i64toi32_i32$HIGH_BITS;
  $15 = $1 & 1048575 | 0 | 1048576 | 0;
  $9 = $15;
  $0 = $9 & 65535 | 0;
  $4 = $11 & 65535 | 0;
  $8 = Math_imul($0, $4);
  $2 = $11 >>> 16 | 0;
  $5 = ($8 >>> 16 | 0) + Math_imul($0, $2) | 0;
  $0 = $9 >>> 16 | 0;
  $4 = Math_imul($4, $0) + ($5 & 65535 | 0) | 0;
  i64toi32_i32$HIGH_BITS = (Math_imul($0, $2) + ($5 >>> 16 | 0) | 0) + ($4 >>> 16 | 0) | 0;
  $10 = $8 & 65535 | 0 | ($4 << 16 | 0) | 0;
  $2 = i64toi32_i32$HIGH_BITS;
  $0 = $3 & 65535 | 0;
  $5 = $6 & 65535 | 0;
  $4 = Math_imul($0, $5);
  $8 = $6 >>> 16 | 0;
  $11 = ($4 >>> 16 | 0) + Math_imul($0, $8) | 0;
  $0 = $3 >>> 16 | 0;
  $5 = Math_imul($5, $0) + ($11 & 65535 | 0) | 0;
  i64toi32_i32$HIGH_BITS = (Math_imul($0, $8) + ($11 >>> 16 | 0) | 0) + ($5 >>> 16 | 0) | 0;
  $0 = i64toi32_i32$HIGH_BITS;
  $5 = ($4 & 65535 | 0 | ($5 << 16 | 0) | 0) + $16 | 0;
  if ($5 >>> 0 < $16 >>> 0) {
   $0 = $0 + 1 | 0
  }
  $8 = $0;
  $0 = $2;
  $4 = $5 + $10 | 0;
  if ($4 >>> 0 < $5 >>> 0) {
   $0 = $0 + 1 | 0
  }
  $2 = $0;
  $0 = $9 & 65535 | 0;
  $10 = $3 & 65535 | 0;
  $5 = Math_imul($0, $10);
  $3 = $3 >>> 16 | 0;
  $11 = ($5 >>> 16 | 0) + Math_imul($0, $3) | 0;
  $0 = $9 >>> 16 | 0;
  $10 = Math_imul($10, $0) + ($11 & 65535 | 0) | 0;
  i64toi32_i32$HIGH_BITS = (Math_imul($0, $3) + ($11 >>> 16 | 0) | 0) + ($10 >>> 16 | 0) | 0;
  $0 = i64toi32_i32$HIGH_BITS;
  $3 = ($5 & 65535 | 0 | ($10 << 16 | 0) | 0) + $8 | 0;
  if ($3 >>> 0 < $8 >>> 0) {
   $0 = $0 + 1 | 0
  }
  $8 = $2 + $3 | 0;
  if ($8 >>> 0 < $2 >>> 0) {
   $0 = $0 + 1 | 0
  }
  $lib_math_res128_hi = $8;
  $lib_math_res128_hi$hi = $0;
  $0 = $14 & 65535 | 0;
  $3 = $6 & 65535 | 0;
  $8 = Math_imul($0, $3);
  $2 = $6 >>> 16 | 0;
  $5 = ($8 >>> 16 | 0) + Math_imul($0, $2) | 0;
  $0 = $14 >>> 16 | 0;
  $3 = Math_imul($3, $0) + ($5 & 65535 | 0) | 0;
  i64toi32_i32$HIGH_BITS = (((Math_imul($0, $2) + Math_imul($14, $15) | 0) + Math_imul($6, $18) | 0) + ($5 >>> 16 | 0) | 0) + ($3 >>> 16 | 0) | 0;
  $0 = $lib_math_res128_hi$hi + i64toi32_i32$HIGH_BITS | 0;
  $2 = $8 & 65535 | 0 | ($3 << 16 | 0) | 0;
  $5 = $2 + $lib_math_res128_hi | 0;
  if ($5 >>> 0 < $2 >>> 0) {
   $0 = $0 + 1 | 0
  }
  $2 = $15 & 65535 | 0;
  $6 = $12 & 65535 | 0;
  $3 = Math_imul($2, $6);
  $8 = $12 >>> 16 | 0;
  $10 = ($3 >>> 16 | 0) + Math_imul($2, $8) | 0;
  $2 = $15 >>> 16 | 0;
  $6 = Math_imul($6, $2) + ($10 & 65535 | 0) | 0;
  i64toi32_i32$HIGH_BITS = ((Math_imul($2, $8) + Math_imul($15 >> 31 | 0, $12) | 0) + ($10 >>> 16 | 0) | 0) + ($6 >>> 16 | 0) | 0;
  $2 = $3 & 65535 | 0 | ($6 << 16 | 0) | 0;
  $3 = i64toi32_i32$HIGH_BITS;
  $4 = $3 + ($7 >>> 0 < 0 >>> 0 ? $4 + 1 | 0 : $4) | 0;
  $6 = $7 + $2 | 0;
  if ($6 >>> 0 < $7 >>> 0) {
   $4 = $4 + 1 | 0
  }
  $2 = ($3 | 0) == ($4 | 0) & $6 >>> 0 < $2 >>> 0 | 0 | $4 >>> 0 < $3 >>> 0 | 0;
  $3 = $2 + $5 | 0;
  if ($3 >>> 0 < $2 >>> 0) {
   $0 = $0 + 1 | 0
  }
  $8 = $0;
  $15 = $0 << 2 | 0 | ($3 >>> 30 | 0) | 0;
  $5 = $15 >> 31 | 0;
  $18 = $5;
  $7 = $4;
  $2 = ($3 << 2 | 0 | ($4 >>> 30 | 0) | 0) ^ (($5 & 1 | 0) << 31 | 0 | ($5 >>> 1 | 0) | 0) | 0;
  $3 = $2;
  $0 = ($5 >> 1 | 0) ^ $15 | 0;
  $17 = Math_clz32($0);
  if (($17 | 0) == (32 | 0)) {
   $17 = Math_clz32($2) + 32 | 0
  }
  $2 = $17 & 31 | 0;
  if (32 >>> 0 <= ($17 & 63 | 0) >>> 0) {
   $0 = $3 << $2 | 0;
   $2 = 0;
  } else {
   $0 = ((1 << $2 | 0) - 1 | 0) & ($3 >>> (32 - $2 | 0) | 0) | 0 | ($0 << $2 | 0) | 0;
   $2 = $3 << $2 | 0;
  }
  $3 = ($6 << 2 | 0) ^ $18 | 0;
  $12 = $3;
  $11 = ($7 << 2 | 0 | ($6 >>> 30 | 0) | 0) ^ $5 | 0;
  $6 = $11;
  $7 = 64 - $17 | 0;
  $4 = $7 & 31 | 0;
  if (32 >>> 0 <= ($7 & 63 | 0) >>> 0) {
   $9 = $6 >>> $4 | 0;
   $4 = 0;
  } else {
   $9 = (((1 << $4 | 0) - 1 | 0) & $6 | 0) << (32 - $4 | 0) | 0 | ($3 >>> $4 | 0) | 0;
   $4 = $6 >>> $4 | 0;
  }
  $5 = $2 | $9 | 0;
  $10 = $5;
  $2 = $5 >>> 16 | 0;
  $3 = $5 & 65535 | 0;
  $7 = Math_imul($3, 49716);
  $6 = Math_imul($2, 49716) + ($7 >>> 16 | 0) | 0;
  $9 = Math_imul($2, 8552) + ($6 >>> 16 | 0) | 0;
  $2 = Math_imul($3, 8552) + ($6 & 65535 | 0) | 0;
  i64toi32_i32$HIGH_BITS = $9 + ($2 >>> 16 | 0) | 0;
  $7 = $7 & 65535 | 0 | ($2 << 16 | 0) | 0;
  $16 = i64toi32_i32$HIGH_BITS;
  $14 = $0 | $4 | 0;
  $9 = $14;
  $0 = $9 >>> 16 | 0;
  $3 = $9 & 65535 | 0;
  $2 = Math_imul($3, 49716);
  $6 = Math_imul($0, 49716) + ($2 >>> 16 | 0) | 0;
  $4 = Math_imul($0, 8552) + ($6 >>> 16 | 0) | 0;
  $0 = Math_imul($3, 8552) + ($6 & 65535 | 0) | 0;
  i64toi32_i32$HIGH_BITS = $4 + ($0 >>> 16 | 0) | 0;
  $4 = $2 & 65535 | 0 | ($0 << 16 | 0) | 0;
  $2 = i64toi32_i32$HIGH_BITS;
  $0 = $5 >>> 16 | 0;
  $3 = $5 & 65535 | 0;
  $6 = Math_imul($3, 55970);
  $5 = Math_imul($0, 55970) + ($6 >>> 16 | 0) | 0;
  $3 = Math_imul($3, 51471) + ($5 & 65535 | 0) | 0;
  i64toi32_i32$HIGH_BITS = (Math_imul($0, 51471) + ($5 >>> 16 | 0) | 0) + ($3 >>> 16 | 0) | 0;
  $0 = i64toi32_i32$HIGH_BITS;
  $3 = ($6 & 65535 | 0 | ($3 << 16 | 0) | 0) + $16 | 0;
  if ($3 >>> 0 < $16 >>> 0) {
   $0 = $0 + 1 | 0
  }
  $6 = $0;
  $0 = $2;
  $2 = $3 + $4 | 0;
  if ($2 >>> 0 < $3 >>> 0) {
   $0 = $0 + 1 | 0
  }
  $3 = $0;
  $0 = $9 >>> 16 | 0;
  $4 = $9 & 65535 | 0;
  $5 = Math_imul($4, 55970);
  $9 = Math_imul($0, 55970) + ($5 >>> 16 | 0) | 0;
  $4 = Math_imul($4, 51471) + ($9 & 65535 | 0) | 0;
  i64toi32_i32$HIGH_BITS = (Math_imul($0, 51471) + ($9 >>> 16 | 0) | 0) + ($4 >>> 16 | 0) | 0;
  $0 = i64toi32_i32$HIGH_BITS;
  $4 = ($5 & 65535 | 0 | ($4 << 16 | 0) | 0) + $6 | 0;
  if ($4 >>> 0 < $6 >>> 0) {
   $0 = $0 + 1 | 0
  }
  $6 = $3 + $4 | 0;
  if ($6 >>> 0 < $3 >>> 0) {
   $0 = $0 + 1 | 0
  }
  $lib_math_res128_hi = $6;
  $lib_math_res128_hi$hi = $0;
  $0 = $2;
  $3 = $7;
  if ($3 >>> 0 < 0 >>> 0) {
   $0 = $0 + 1 | 0
  }
  $7 = $0;
  $16 = $0;
  $2 = $17 & 31 | 0;
  $19 = 3.753184150245214e-04 * (+($10 >>> 0) + 4294967296.0 * +($14 >>> 0));
  if (32 >>> 0 <= ($17 & 63 | 0) >>> 0) {
   $0 = $12 << $2 | 0;
   $2 = 0;
  } else {
   $0 = ((1 << $2 | 0) - 1 | 0) & ($12 >>> (32 - $2 | 0) | 0) | 0 | ($11 << $2 | 0) | 0;
   $2 = $12 << $2 | 0;
  }
  $13 = $19 + 3.834951969714103e-04 * (+($2 >>> 0) + 4294967296.0 * +($0 >>> 0));
  if (Math_abs($13) >= 1.0) {
   if ($13 > 0.0) {
    $0 = ~~Math_min(Math_floor($13 / 4294967296.0), 4294967295.0) >>> 0
   } else {
    $0 = ~~Math_ceil(($13 - +(~~$13 >>> 0 >>> 0)) / 4294967296.0) >>> 0
   }
  } else {
   $0 = 0
  }
  $9 = ~~$13 >>> 0;
  $11 = $9;
  $2 = $0;
  $10 = $0;
  $5 = $lib_math_res128_hi;
  $4 = $5;
  $6 = $lib_math_res128_hi$hi;
  $0 = $6 >>> 11 | 0;
  $6 = ($6 & 2047 | 0) << 21 | 0 | ($5 >>> 11 | 0) | 0;
  $2 = $6 + (($2 | 0) == ($16 | 0) & $3 >>> 0 < $11 >>> 0 | 0 | $16 >>> 0 < $2 >>> 0 | 0) | 0;
  if ($2 >>> 0 < $6 >>> 0) {
   $0 = $0 + 1 | 0
  }
  $lib_math_rempio2_y0 = +($2 >>> 0) + 4294967296.0 * +($0 >>> 0);
  $0 = ($4 << 21 | 0 | ($7 >>> 11 | 0) | 0) + $10 | 0;
  $7 = ($7 & 2047 | 0) << 21 | 0 | ($3 >>> 11 | 0) | 0;
  $2 = $7 + $11 | 0;
  if ($2 >>> 0 < $7 >>> 0) {
   $0 = $0 + 1 | 0
  }
  $lib_math_rempio2_y1 = 5.421010862427522e-20 * (+($2 >>> 0) + 4294967296.0 * +($0 >>> 0));
  $13 = $lib_math_rempio2_y0;
  wasm2js_scratch_store_i32(0 | 0, 0 | 0);
  wasm2js_scratch_store_i32(1 | 0, 1018167296 - ($17 << 20 | 0) | 0 | (($1 ^ $15 | 0) & -2147483648 | 0) | 0 | 0);
  $19 = $13;
  $13 = +wasm2js_scratch_load_f64();
  $lib_math_rempio2_y0 = $19 * $13;
  $lib_math_rempio2_y1 = $lib_math_rempio2_y1 * $13;
  return ($8 >> 30 | 0) - $18 | 0;
 }
 
 function $lib_math_NativeMath_cos($0) {
  var $1 = 0.0, $2 = 0.0, $3 = 0.0, $4 = 0.0, $5 = 0, $6 = 0, $7 = 0.0, $8 = 0, $9 = 0;
  wasm2js_scratch_store_f64(+$0);
  $5 = wasm2js_scratch_load_i32(1 | 0) | 0;
  $9 = $5;
  $6 = wasm2js_scratch_load_i32(0 | 0) | 0;
  $8 = $5 >>> 31 | 0;
  $5 = $5 & 2147483647 | 0;
  if ($5 >>> 0 <= 1072243195 >>> 0) {
   if ($5 >>> 0 < 1044816030 >>> 0) {
    return 1.0
   }
   $3 = $0 * $0;
   $4 = .5 * $3;
   $2 = 1.0 - $4;
   $1 = 1.0 - $2;
   $4 = $1 - $4;
   $1 = $3 * $3;
   return $2 + ($4 + ($3 * ($3 * (.0416666666666666 + $3 * (-.001388888888887411 + $3 * 2.480158728947673e-05)) + $1 * $1 * (-2.7557314351390663e-07 + $3 * (2.087572321298175e-09 + $3 * -1.1359647557788195e-11))) - $0 * 0.0));
  }
  if ($5 >>> 0 >= 2146435072 >>> 0) {
   return $0 - $0
  }
  $5 = $9 & 2147483647 | 0;
  $lib_math_rempio2_inlined_0 : {
   if ($5 >>> 0 < 1073928572 >>> 0) {
    $6 = 1;
    if ($8) {
     $0 = $0 + 1.5707963267341256;
     $6 = -1;
     if (($5 | 0) != (1073291771 | 0)) {
      $1 = $0;
      $0 = $0 + 6.077100506506192e-11;
      $1 = $1 - $0 + 6.077100506506192e-11;
     } else {
      $1 = $0 + 6.077100506303966e-11;
      $0 = $1 + 2.0222662487959506e-21;
      $1 = $1 - $0 + 2.0222662487959506e-21;
     }
    } else {
     $0 = $0 - 1.5707963267341256;
     if (($5 | 0) != (1073291771 | 0)) {
      $1 = $0;
      $0 = $0 - 6.077100506506192e-11;
      $1 = $1 - $0 - 6.077100506506192e-11;
     } else {
      $1 = $0 - 6.077100506303966e-11;
      $0 = $1 - 2.0222662487959506e-21;
      $1 = $1 - $0 - 2.0222662487959506e-21;
     }
    }
    $lib_math_rempio2_y0 = $0;
    $lib_math_rempio2_y1 = $1;
    break $lib_math_rempio2_inlined_0;
   }
   if ($5 >>> 0 < 1094263291 >>> 0) {
    $8 = $5 >>> 20 | 0;
    $5 = $8;
    $1 = $0;
    $0 = $0 * .6366197723675814;
    $2 = Math_floor($0);
    $4 = $0 - $2;
    __inlined_func$__wasm_nearest_f64 : {
     if ($4 < .5) {
      $0 = $2
     } else {
      $0 = Math_ceil($0);
      if ($4 > .5) {
       break __inlined_func$__wasm_nearest_f64
      }
      $3 = $2 * .5;
      $4 = Math_floor($3);
      $0 = $3 - $4 == 0.0 ? $2 : $0;
     }
    }
    $2 = $1;
    $1 = $0;
    $0 = $2 - $0 * 1.5707963267341256;
    $4 = $1 * 6.077100506506192e-11;
    $2 = $0 - $4;
    wasm2js_scratch_store_f64(+$2);
    $6 = wasm2js_scratch_load_i32(1 | 0) | 0;
    wasm2js_scratch_load_i32(0 | 0) | 0;
    if (($5 - (($6 >>> 20 | 0) & 2047 | 0) | 0) >>> 0 > 16 >>> 0) {
     $3 = $0;
     $2 = $1 * 6.077100506303966e-11;
     $0 = $0 - $2;
     $4 = $1 * 2.0222662487959506e-21 - ($3 - $0 - $2);
     $2 = $0 - $4;
     wasm2js_scratch_store_f64(+$2);
     $6 = wasm2js_scratch_load_i32(1 | 0) | 0;
     wasm2js_scratch_load_i32(0 | 0) | 0;
     if (($8 - (($6 >>> 20 | 0) & 2047 | 0) | 0) >>> 0 > 49 >>> 0) {
      $3 = $0;
      $2 = $1 * 2.0222662487111665e-21;
      $0 = $0 - $2;
      $4 = $1 * 8.4784276603689e-32 - ($3 - $0 - $2);
      $2 = $0 - $4;
     }
    }
    $lib_math_rempio2_y0 = $2;
    $lib_math_rempio2_y1 = $0 - $2 - $4;
    $6 = ~~$1;
    break $lib_math_rempio2_inlined_0;
   }
   $6 = $lib_math_pio2_large_quot($6, $9);
   $6 = $8 ? 0 - $6 | 0 : $6;
  }
  $3 = $lib_math_rempio2_y0;
  $4 = $lib_math_rempio2_y1;
  if ($6 & 1 | 0) {
   $1 = $3 * $3;
   $0 = $1 * $3;
   $0 = $3 - ($1 * (.5 * $4 - $0 * (.00833333333332249 + $1 * (-1.984126982985795e-04 + $1 * 2.7557313707070068e-06) + $1 * ($1 * $1) * (-2.5050760253406863e-08 + $1 * 1.58969099521155e-10))) - $4 - $0 * -.16666666666666632);
  } else {
   $7 = $3 * $3;
   $2 = .5 * $7;
   $1 = 1.0 - $2;
   $0 = 1.0 - $1;
   $2 = $0 - $2;
   $0 = $7 * $7;
   $0 = $1 + ($2 + ($7 * ($7 * (.0416666666666666 + $7 * (-.001388888888887411 + $7 * 2.480158728947673e-05)) + $0 * $0 * (-2.7557314351390663e-07 + $7 * (2.087572321298175e-09 + $7 * -1.1359647557788195e-11))) - $3 * $4));
  }
  return ($6 + 1 | 0) & 2 | 0 ? -$0 : $0;
 }
 
 function index_SolveCubic() {
  var $0 = 0.0, $1 = 0, $2 = 0.0, $3 = 0.0, $4 = 0.0, $5 = 0, $6 = 0.0, $7 = 0.0;
  $1 = HEAP32[(index_input + 4 | 0) >> 2];
  $0 = HEAPF64[$1 >> 3];
  $0 = 1.0 / $0;
  $4 = HEAPF64[($1 + 8 | 0) >> 3] * $0;
  $2 = $4 * $4;
  $3 = HEAPF64[($1 + 16 | 0) >> 3] * $0;
  $6 = -.3333333333333333 * $2 + $3;
  $0 = .5 * (.07407407407407407 * $4 * $2 - .3333333333333333 * $4 * $3 + HEAPF64[($1 + 24 | 0) >> 3] * $0);
  $2 = .3333333333333333 * $6;
  $6 = $2 * $2 * $2;
  $3 = $0 * $0 + $6;
  $7 = $3;
  if (Math_abs($3) < 1.0e-09) {
   if (Math_abs($0) < 1.0e-09) {
    HEAPF64[HEAP32[(index_output + 4 | 0) >> 2] >> 3] = 0.0;
    $1 = 1;
   } else {
    $0 = $lib_math_NativeMath_cbrt(-$0);
    $1 = index_output;
    HEAPF64[HEAP32[($1 + 4 | 0) >> 2] >> 3] = 2.0 * $0;
    HEAPF64[(HEAP32[($1 + 4 | 0) >> 2] + 8 | 0) >> 3] = -$0;
    $1 = 2;
   }
  } else {
   if ($3 < 0.0) {
    $0 = $lib_math_NativeMath_acos(-$0 / Math_sqrt(-$6));
    $1 = index_output;
    $0 = .3333333333333333 * $0;
    $3 = $lib_math_NativeMath_cos($0);
    $2 = 2.0 * Math_sqrt(-$2);
    HEAPF64[HEAP32[($1 + 4 | 0) >> 2] >> 3] = $2 * $3;
    $1 = index_output;
    $3 = $lib_math_NativeMath_cos($0 + 1.0471975511965976);
    $2 = -$2;
    HEAPF64[(HEAP32[($1 + 4 | 0) >> 2] + 8 | 0) >> 3] = $2 * $3;
    $1 = index_output;
    $0 = $lib_math_NativeMath_cos($0 - 1.0471975511965976);
    HEAPF64[(HEAP32[($1 + 4 | 0) >> 2] + 16 | 0) >> 3] = $2 * $0;
    $1 = 3;
   } else {
    $2 = Math_sqrt($7);
    $3 = $lib_math_NativeMath_cbrt($2 - $0);
    $0 = $lib_math_NativeMath_cbrt($2 + $0);
    HEAPF64[HEAP32[(index_output + 4 | 0) >> 2] >> 3] = $3 + -$0;
    $1 = 1;
   }
  }
  $0 = .3333333333333333 * $4;
  if (($1 | 0) > (0 | 0)) {
   $5 = HEAP32[(index_output + 4 | 0) >> 2];
   $4 = HEAPF64[$5 >> 3] - $0;
   HEAPF64[$5 >> 3] = $4;
  }
  if (($1 | 0) > (1 | 0)) {
   $5 = HEAP32[(index_output + 4 | 0) >> 2];
   $4 = HEAPF64[($5 + 8 | 0) >> 3] - $0;
   HEAPF64[($5 + 8 | 0) >> 3] = $4;
  }
  if (($1 | 0) > (2 | 0)) {
   $5 = HEAP32[(index_output + 4 | 0) >> 2];
   $0 = HEAPF64[($5 + 16 | 0) >> 3] - $0;
   HEAPF64[($5 + 16 | 0) >> 3] = $0;
  }
  return $1 | 0;
 }
 
 function index_SolveQuartic() {
  var $0 = 0, $1 = 0.0, $2 = 0, $3 = 0.0, $4 = 0.0, $5 = 0.0, $6 = 0.0, $7 = 0.0, $8 = 0.0, $9 = 0;
  $0 = HEAP32[(index_input + 4 | 0) >> 2];
  $1 = HEAPF64[$0 >> 3];
  $3 = 1.0 / $1;
  $6 = HEAPF64[($0 + 8 | 0) >> 3] * $3;
  $4 = $6 * $6;
  $5 = HEAPF64[($0 + 16 | 0) >> 3] * $3;
  $7 = -.375 * $4 + $5;
  $1 = HEAPF64[($0 + 24 | 0) >> 3] * $3;
  $8 = .125 * $4 * $6 - .5 * $6 * $5 + $1;
  $1 = -.01171875 * $4 * $4 + .0625 * $4 * $5 - .25 * $6 * $1 + HEAPF64[($0 + 32 | 0) >> 3] * $3;
  if (Math_abs($1) < 1.0e-09) {
   $0 = index_output;
   HEAPF64[(HEAP32[($0 + 4 | 0) >> 2] + 24 | 0) >> 3] = $8;
   HEAPF64[(HEAP32[($0 + 4 | 0) >> 2] + 16 | 0) >> 3] = $7;
   HEAPF64[(HEAP32[($0 + 4 | 0) >> 2] + 8 | 0) >> 3] = 0.0;
   HEAPF64[HEAP32[($0 + 4 | 0) >> 2] >> 3] = 1.0;
   $0 = index_SolveCubic();
  } else {
   $0 = index_input;
   HEAPF64[(HEAP32[($0 + 4 | 0) >> 2] + 24 | 0) >> 3] = .5 * $1 * $7 - .125 * $8 * $8;
   HEAPF64[(HEAP32[($0 + 4 | 0) >> 2] + 16 | 0) >> 3] = -$1;
   HEAPF64[(HEAP32[($0 + 4 | 0) >> 2] + 8 | 0) >> 3] = -.5 * $7;
   HEAPF64[HEAP32[($0 + 4 | 0) >> 2] >> 3] = 1.0;
   index_SolveCubic();
   $4 = HEAPF64[HEAP32[(index_output + 4 | 0) >> 2] >> 3];
   $3 = 2.0 * $4 - $7;
   $1 = $4 * $4 - $1;
   if (Math_abs($1) < 1.0e-09) {
    $1 = 0.0
   } else {
    if ($1 > 0.0) {
     $1 = Math_sqrt($1)
    } else {
     return 0 | 0
    }
   }
   $5 = $1;
   if (Math_abs($3) < 1.0e-09) {
    $1 = 0.0
   } else {
    if ($3 > 0.0) {
     $1 = Math_sqrt($3)
    } else {
     return 0 | 0
    }
   }
   $0 = index_input;
   HEAPF64[(HEAP32[($0 + 4 | 0) >> 2] + 16 | 0) >> 3] = $4 - $5;
   $3 = -$1;
   $2 = $8 < 0.0;
   HEAPF64[(HEAP32[($0 + 4 | 0) >> 2] + 8 | 0) >> 3] = $2 ? $3 : $1;
   HEAPF64[HEAP32[($0 + 4 | 0) >> 2] >> 3] = 1.0;
   $0 = index_SolveQuadric(0, 1);
   $9 = index_input;
   HEAPF64[(HEAP32[($9 + 4 | 0) >> 2] + 16 | 0) >> 3] = $4 + $5;
   HEAPF64[(HEAP32[($9 + 4 | 0) >> 2] + 8 | 0) >> 3] = $2 ? $1 : $3;
   HEAPF64[HEAP32[($9 + 4 | 0) >> 2] >> 3] = 1.0;
   if (!$0) {
    $0 = index_SolveQuadric(0, 1) + $0 | 0
   }
   if (($0 | 0) == (1 | 0)) {
    $0 = index_SolveQuadric(1, 2) + $0 | 0
   }
   if (($0 | 0) == (2 | 0)) {
    $0 = index_SolveQuadric(2, 3) + $0 | 0
   }
  }
  $5 = .25 * $6;
  if (($0 | 0) > (0 | 0)) {
   $2 = HEAP32[(index_output + 4 | 0) >> 2];
   $1 = HEAPF64[$2 >> 3] - $5;
   HEAPF64[$2 >> 3] = $1;
  }
  if (($0 | 0) > (1 | 0)) {
   $2 = HEAP32[(index_output + 4 | 0) >> 2];
   $1 = HEAPF64[($2 + 8 | 0) >> 3] - $5;
   HEAPF64[($2 + 8 | 0) >> 3] = $1;
  }
  if (($0 | 0) > (2 | 0)) {
   $2 = HEAP32[(index_output + 4 | 0) >> 2];
   $1 = HEAPF64[($2 + 16 | 0) >> 3] - $5;
   HEAPF64[($2 + 16 | 0) >> 3] = $1;
  }
  if (($0 | 0) > (3 | 0)) {
   $2 = HEAP32[(index_output + 4 | 0) >> 2];
   $1 = HEAPF64[($2 + 24 | 0) >> 3] - $5;
   HEAPF64[($2 + 24 | 0) >> 3] = $1;
  }
  return $0 | 0;
 }
 
 function $lib_typedarray_Float64Array_fill($0) {
  var $1 = 0, $2 = 0, $3 = 0;
  if ($0 >>> 0 > 1644 >>> 0) {
   $2 = $0 - 16 | 0;
   $1 = HEAP32[($2 + 4 | 0) >> 2] + 1 | 0;
   HEAP32[($2 + 4 | 0) >> 2] = $1;
  }
  $2 = $0;
  $3 = HEAP32[($0 + 4 | 0) >> 2];
  $1 = HEAP32[($0 + 8 | 0) >> 2] >>> 3 | 0;
  $0 = (0 | 0) < ($1 | 0);
  $0 = $0 ? 0 : $1;
  $1 = (2147483647 | 0) < ($1 | 0) ? 2147483647 : $1;
  for_loop_0 : while (1) {
   if (($0 | 0) < ($1 | 0)) {
    HEAPF64[(($0 << 3 | 0) + $3 | 0) >> 3] = 0.0;
    $0 = $0 + 1 | 0;
    continue for_loop_0;
   }
   break for_loop_0;
  };
  return $2;
 }
 
 function $lib_math_NativeMath_sin($0) {
  var $1 = 0.0, $2 = 0.0, $3 = 0.0, $4 = 0, $5 = 0, $6 = 0.0, $7 = 0.0, $8 = 0, $9 = 0;
  wasm2js_scratch_store_f64(+$0);
  $4 = wasm2js_scratch_load_i32(1 | 0) | 0;
  $9 = $4;
  $5 = wasm2js_scratch_load_i32(0 | 0) | 0;
  $8 = $4 >>> 31 | 0;
  $4 = $4 & 2147483647 | 0;
  if ($4 >>> 0 <= 1072243195 >>> 0) {
   if ($4 >>> 0 < 1045430272 >>> 0) {
    return $0
   }
   $2 = $0 * $0;
   $1 = -1.984126982985795e-04 + $2 * 2.7557313707070068e-06;
   return $0 + $2 * $0 * (-.16666666666666632 + $2 * (.00833333333332249 + $2 * $1 + $2 * ($2 * $2) * (-2.5050760253406863e-08 + $2 * 1.58969099521155e-10)));
  }
  if ($4 >>> 0 >= 2146435072 >>> 0) {
   return $0 - $0
  }
  $4 = $9 & 2147483647 | 0;
  $lib_math_rempio2_inlined_1 : {
   if ($4 >>> 0 < 1073928572 >>> 0) {
    $5 = 1;
    if ($8) {
     $0 = $0 + 1.5707963267341256;
     $5 = -1;
     if (($4 | 0) != (1073291771 | 0)) {
      $1 = $0;
      $0 = $0 + 6.077100506506192e-11;
      $1 = $1 - $0 + 6.077100506506192e-11;
     } else {
      $1 = $0 + 6.077100506303966e-11;
      $0 = $1 + 2.0222662487959506e-21;
      $1 = $1 - $0 + 2.0222662487959506e-21;
     }
    } else {
     $0 = $0 - 1.5707963267341256;
     if (($4 | 0) != (1073291771 | 0)) {
      $1 = $0;
      $0 = $0 - 6.077100506506192e-11;
      $1 = $1 - $0 - 6.077100506506192e-11;
     } else {
      $1 = $0 - 6.077100506303966e-11;
      $0 = $1 - 2.0222662487959506e-21;
      $1 = $1 - $0 - 2.0222662487959506e-21;
     }
    }
    $lib_math_rempio2_y0 = $0;
    $lib_math_rempio2_y1 = $1;
    break $lib_math_rempio2_inlined_1;
   }
   if ($4 >>> 0 < 1094263291 >>> 0) {
    $8 = $4 >>> 20 | 0;
    $4 = $8;
    $1 = $0;
    $0 = $0 * .6366197723675814;
    $2 = Math_floor($0);
    $3 = $0 - $2;
    __inlined_func$__wasm_nearest_f64 : {
     if ($3 < .5) {
      $0 = $2
     } else {
      $0 = Math_ceil($0);
      if ($3 > .5) {
       break __inlined_func$__wasm_nearest_f64
      }
      $6 = $2 * .5;
      $3 = Math_floor($6);
      $0 = $6 - $3 == 0.0 ? $2 : $0;
     }
    }
    $2 = $1;
    $1 = $0;
    $0 = $2 - $0 * 1.5707963267341256;
    $3 = $1 * 6.077100506506192e-11;
    $2 = $0 - $3;
    wasm2js_scratch_store_f64(+$2);
    $5 = wasm2js_scratch_load_i32(1 | 0) | 0;
    wasm2js_scratch_load_i32(0 | 0) | 0;
    if (($4 - (($5 >>> 20 | 0) & 2047 | 0) | 0) >>> 0 > 16 >>> 0) {
     $3 = $0;
     $2 = $1 * 6.077100506303966e-11;
     $0 = $0 - $2;
     $3 = $1 * 2.0222662487959506e-21 - ($3 - $0 - $2);
     $2 = $0 - $3;
     wasm2js_scratch_store_f64(+$2);
     $5 = wasm2js_scratch_load_i32(1 | 0) | 0;
     wasm2js_scratch_load_i32(0 | 0) | 0;
     if (($8 - (($5 >>> 20 | 0) & 2047 | 0) | 0) >>> 0 > 49 >>> 0) {
      $3 = $0;
      $2 = $1 * 2.0222662487111665e-21;
      $0 = $0 - $2;
      $3 = $1 * 8.4784276603689e-32 - ($3 - $0 - $2);
      $2 = $0 - $3;
     }
    }
    $lib_math_rempio2_y0 = $2;
    $lib_math_rempio2_y1 = $0 - $2 - $3;
    $5 = ~~$1;
    break $lib_math_rempio2_inlined_1;
   }
   $5 = $lib_math_pio2_large_quot($5, $9);
   $5 = $8 ? 0 - $5 | 0 : $5;
  }
  $6 = $lib_math_rempio2_y0;
  $3 = $lib_math_rempio2_y1;
  if ($5 & 1 | 0) {
   $7 = $6 * $6;
   $2 = .5 * $7;
   $1 = 1.0 - $2;
   $0 = 1.0 - $1;
   $2 = $0 - $2;
   $0 = $7 * $7;
   $0 = $1 + ($2 + ($7 * ($7 * (.0416666666666666 + $7 * (-.001388888888887411 + $7 * 2.480158728947673e-05)) + $0 * $0 * (-2.7557314351390663e-07 + $7 * (2.087572321298175e-09 + $7 * -1.1359647557788195e-11))) - $6 * $3));
  } else {
   $1 = $6 * $6;
   $0 = $1 * $6;
   $0 = $6 - ($1 * (.5 * $3 - $0 * (.00833333333332249 + $1 * (-1.984126982985795e-04 + $1 * 2.7557313707070068e-06) + $1 * ($1 * $1) * (-2.5050760253406863e-08 + $1 * 1.58969099521155e-10))) - $3 - $0 * -.16666666666666632);
  }
  return $5 & 2 | 0 ? -$0 : $0;
 }
 
 function index_range() {
  var $0 = 0, $1 = 0.0, $2 = 0.0, $3 = 0.0, $4 = 0.0, $5 = 0.0;
  $0 = $lib_typedarray_Float64Array_fill(index_output);
  if ($0 >>> 0 > 1644 >>> 0) {
   $lib_rt_pure_decrement($0 - 16 | 0)
  }
  $0 = HEAP32[(index_input + 4 | 0) >> 2];
  $3 = HEAPF64[($0 + 48 | 0) >> 3];
  $4 = HEAPF64[($0 + 56 | 0) >> 3];
  $1 = HEAPF64[($0 + 40 | 0) >> 3];
  $5 = $lib_math_NativeMath_cos(.7853981633974483);
  $2 = $lib_math_NativeMath_sin(.7853981633974483);
  HEAPF64[(HEAP32[(index_output + 4 | 0) >> 2] + 48 | 0) >> 3] = $1 * $5 / $3 * ($1 * $2 + Math_sqrt($1 * $1 * $2 * $2 + 2.0 * $3 * $4));
  $0 = $lib_typedarray_Float64Array_fill(index_input);
  if ($0 >>> 0 > 1644 >>> 0) {
   $lib_rt_pure_decrement($0 - 16 | 0)
  }
  return HEAPF64[(HEAP32[(index_output + 4 | 0) >> 2] + 48 | 0) >> 3] > 0.0 | 0;
 }
 
 function $lib_math_NativeMath_atan($0) {
  var $1 = 0.0, $2 = 0, $3 = 0, $4 = 0, $5 = 0.0, $6 = 0.0;
  $6 = $0;
  wasm2js_scratch_store_f64(+$0);
  $2 = wasm2js_scratch_load_i32(1 | 0) | 0;
  wasm2js_scratch_load_i32(0 | 0) | 0;
  $2 = $2 & 2147483647 | 0;
  if ($2 >>> 0 >= 1141899264 >>> 0) {
   if ($0 != $0) {
    return $0
   }
   wasm2js_scratch_store_f64(+(1.5707963267948966));
   $2 = wasm2js_scratch_load_i32(1 | 0) | 0;
   $3 = wasm2js_scratch_load_i32(0 | 0) | 0;
   wasm2js_scratch_store_f64(+$6);
   $4 = wasm2js_scratch_load_i32(1 | 0) | 0;
   wasm2js_scratch_load_i32(0 | 0) | 0;
   wasm2js_scratch_store_i32(0 | 0, $3 | 0);
   wasm2js_scratch_store_i32(1 | 0, $2 & 2147483647 | 0 | ($4 & -2147483648 | 0) | 0 | 0);
   return +wasm2js_scratch_load_f64();
  }
  if ($2 >>> 0 < 1071382528 >>> 0) {
   if ($2 >>> 0 < 1044381696 >>> 0) {
    return $0
   }
   $3 = -1;
  } else {
   $0 = Math_abs($0);
   if ($2 >>> 0 < 1072889856 >>> 0) {
    if ($2 >>> 0 < 1072037888 >>> 0) {
     $0 = (2.0 * $0 - 1.0) / (2.0 + $0)
    } else {
     $3 = 1;
     $0 = ($0 - 1.0) / ($0 + 1.0);
    }
   } else {
    if ($2 >>> 0 < 1073971200 >>> 0) {
     $3 = 2;
     $0 = ($0 - 1.5) / (1.0 + 1.5 * $0);
    } else {
     $3 = 3;
     $0 = -1.0 / $0;
    }
   }
  }
  $5 = $0 * $0;
  $1 = $5 * $5;
  $1 = $0 * ($5 * (.3333333333333293 + $1 * (.14285714272503466 + $1 * (.09090887133436507 + $1 * (.06661073137387531 + $1 * (.049768779946159324 + $1 * .016285820115365782))))) + $1 * (-.19999999999876483 + $1 * (-.11111110405462356 + $1 * (-.0769187620504483 + $1 * (-.058335701337905735 + $1 * -.036531572744216916)))));
  if (($3 | 0) < (0 | 0)) {
   return $0 - $1
  }
  break_0 : {
   case4_0 : {
    switch ($3 | 0) {
    case 0:
     $0 = .4636476090008061 - ($1 - 2.2698777452961687e-17 - $0);
     break break_0;
    case 1:
     $0 = .7853981633974483 - ($1 - 3.061616997868383e-17 - $0);
     break break_0;
    case 2:
     $0 = .982793723247329 - ($1 - 1.3903311031230998e-17 - $0);
     break break_0;
    case 3:
     $0 = 1.5707963267948966 - ($1 - 6.123233995736766e-17 - $0);
     break break_0;
    default:
     break case4_0;
    };
   }
   abort();
  }
  wasm2js_scratch_store_f64(+$0);
  $2 = wasm2js_scratch_load_i32(1 | 0) | 0;
  $3 = wasm2js_scratch_load_i32(0 | 0) | 0;
  wasm2js_scratch_store_f64(+$6);
  $4 = wasm2js_scratch_load_i32(1 | 0) | 0;
  wasm2js_scratch_load_i32(0 | 0) | 0;
  wasm2js_scratch_store_i32(0 | 0, $3 | 0);
  wasm2js_scratch_store_i32(1 | 0, $2 & 2147483647 | 0 | ($4 & -2147483648 | 0) | 0 | 0);
  return +wasm2js_scratch_load_f64();
 }
 
 function $lib_math_NativeMath_atan2($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  if ($1 != $1 ? 1 : $0 != $0) {
   return $1 + $0
  }
  wasm2js_scratch_store_f64(+$0);
  $2 = wasm2js_scratch_load_i32(1 | 0) | 0;
  $5 = wasm2js_scratch_load_i32(0 | 0) | 0;
  $3 = $2;
  wasm2js_scratch_store_f64(+$1);
  $4 = wasm2js_scratch_load_i32(1 | 0) | 0;
  $2 = wasm2js_scratch_load_i32(0 | 0) | 0;
  $6 = $2;
  if (!($4 - 1072693248 | 0 | $2 | 0)) {
   return $lib_math_NativeMath_atan($0)
  }
  $2 = ($4 >>> 30 | 0) & 2 | 0 | ($3 >>> 31 | 0) | 0;
  $4 = $4 & 2147483647 | 0;
  $3 = $3 & 2147483647 | 0;
  if (!($3 | $5 | 0)) {
   break_0 : {
    case3_0 : {
     case2_0 : {
      case1_0 : {
       if (!$2) {
        break case1_0
       }
       tablify_0 : {
        switch ($2 - 1 | 0 | 0) {
        case 0:
         break case1_0;
        case 1:
         break case2_0;
        case 2:
         break case3_0;
        default:
         break tablify_0;
        };
       }
       break break_0;
      }
      return $0;
     }
     return 3.141592653589793;
    }
    return -3.141592653589793;
   }
  }
  folding_inner0 : {
   if (!($4 | $6 | 0)) {
    break folding_inner0
   }
   if (($4 | 0) == (2146435072 | 0)) {
    if (($3 | 0) == (2146435072 | 0)) {
     $0 = $2 & 2 | 0 ? 2.356194490192345 : .7853981633974483
    } else {
     $0 = $2 & 2 | 0 ? 3.141592653589793 : 0.0
    }
    return $2 & 1 | 0 ? -$0 : $0;
   }
   if (($4 + 67108864 | 0) >>> 0 < $3 >>> 0 ? 1 : ($3 | 0) == (2146435072 | 0)) {
    break folding_inner0
   }
   if ($2 & 2 | 0 ? ($3 + 67108864 | 0) >>> 0 < $4 >>> 0 : 0) {
    $0 = 0.0
   } else {
    $0 = $lib_math_NativeMath_atan(Math_abs($0 / $1))
   }
   break_1 : {
    case3_1 : {
     case2_1 : {
      case1_1 : {
       if ($2) {
        switch ($2 - 1 | 0 | 0) {
        case 0:
         break case1_1;
        case 1:
         break case2_1;
        case 2:
         break case3_1;
        default:
         break break_1;
        }
       }
       return $0;
      }
      return -$0;
     }
     return 3.141592653589793 - ($0 - 1.2246467991473532e-16);
    }
    return $0 - 1.2246467991473532e-16 - 3.141592653589793;
   }
   abort();
  }
  return $2 & 1 | 0 ? -1.5707963267948966 : 1.5707963267948966;
 }
 
 function index_solveArcStatic() {
  var $0 = 0.0, $1 = 0, $2 = 0.0, $3 = 0.0, $4 = 0.0, $5 = 0.0, $6 = 0, $7 = 0.0, $8 = 0.0, $9 = 0.0;
  $1 = $lib_typedarray_Float64Array_fill(index_output);
  if ($1 >>> 0 > 1644 >>> 0) {
   $lib_rt_pure_decrement($1 - 16 | 0)
  }
  $1 = HEAP32[(index_input + 4 | 0) >> 2];
  $4 = HEAPF64[($1 + 72 | 0) >> 3];
  $2 = HEAPF64[($1 + 96 | 0) >> 3];
  $3 = $4 - HEAPF64[($1 + 40 | 0) >> 3];
  $4 = HEAPF64[($1 + 80 | 0) >> 3] - HEAPF64[($1 + 48 | 0) >> 3];
  $8 = HEAPF64[($1 + 88 | 0) >> 3] - HEAPF64[($1 + 56 | 0) >> 3];
  $7 = Math_sqrt($3 * $3 + $4 * $4 + $8 * $8);
  $0 = $2 * $7;
  $9 = $0 * $7;
  $7 = HEAPF64[($1 - -64 | 0) >> 3];
  $5 = $7 * $7;
  $9 = $9 + 2.0 * $4 * $5;
  $2 = $5 * $5 - $2 * $9;
  if ($2 < 0.0) {
   return 0 | 0
  }
  $9 = Math_sqrt($2);
  $2 = $lib_math_NativeMath_atan2($5 - $9, $0);
  $5 = $lib_math_NativeMath_atan2($5 + $9, $0);
  $1 = $2 != $5 ? 2 : 1;
  $0 = $3 * $3 + $4 * $4 + $8 * $8;
  if ($0 > 0.0) {
   $0 = 1.0 / Math_sqrt($0);
   $3 = $3 * $0;
   $8 = $8 * $0;
   $4 = $4 * $0;
  }
  $0 = $lib_math_NativeMath_cos($2);
  $2 = $lib_math_NativeMath_sin($2);
  $6 = index_output;
  $0 = $0 * $7;
  HEAPF64[(HEAP32[($6 + 4 | 0) >> 2] + 48 | 0) >> 3] = $3 * $0;
  HEAPF64[(HEAP32[($6 + 4 | 0) >> 2] + 56 | 0) >> 3] = $4 * $0 + $2 * $7;
  HEAPF64[(HEAP32[($6 + 4 | 0) >> 2] - -64 | 0) >> 3] = $8 * $0;
  if (($1 | 0) > (1 | 0)) {
   $0 = $lib_math_NativeMath_cos($5);
   $5 = $lib_math_NativeMath_sin($5);
   $6 = index_output;
   $2 = $3;
   $3 = $0 * $7;
   HEAPF64[(HEAP32[($6 + 4 | 0) >> 2] + 72 | 0) >> 3] = $2 * $3;
   HEAPF64[(HEAP32[($6 + 4 | 0) >> 2] + 80 | 0) >> 3] = $4 * $3 + $5 * $7;
   HEAPF64[(HEAP32[($6 + 4 | 0) >> 2] + 88 | 0) >> 3] = $8 * $3;
  }
  $6 = $lib_typedarray_Float64Array_fill(index_input);
  if ($6 >>> 0 > 1644 >>> 0) {
   $lib_rt_pure_decrement($6 - 16 | 0)
  }
  return $1 | 0;
 }
 
 function $lib_typedarray_Float64Array_subarray($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0;
  if ($0 >>> 0 > 1644 >>> 0) {
   $1 = $0 - 16 | 0;
   $2 = HEAP32[($1 + 4 | 0) >> 2] + 1 | 0;
   HEAP32[($1 + 4 | 0) >> 2] = $2;
  }
  $1 = HEAP32[($0 + 8 | 0) >> 2] >>> 3 | 0;
  $2 = (0 | 0) < ($1 | 0);
  $2 = $2 ? 0 : $1;
  $3 = (6 | 0) < ($1 | 0) ? 6 : $1;
  $1 = $lib_rt_tlsf_allocateBlock($lib_rt_tlsf_maybeInitialize(), 12, 3) + 16 | 0;
  $6 = $1;
  $4 = HEAP32[$0 >> 2];
  if ($4 >>> 0 > 1644 >>> 0) {
   $5 = $4 - 16 | 0;
   HEAP32[($5 + 4 | 0) >> 2] = HEAP32[($5 + 4 | 0) >> 2] + 1 | 0;
  }
  HEAP32[$6 >> 2] = $4;
  HEAP32[($1 + 4 | 0) >> 2] = HEAP32[($0 + 4 | 0) >> 2] + ($2 << 3 | 0) | 0;
  HEAP32[($1 + 8 | 0) >> 2] = ((($3 | 0) > ($2 | 0) ? $3 : $2) - $2 | 0) << 3 | 0;
  if ($1 >>> 0 > 1644 >>> 0) {
   $2 = $1 - 16 | 0;
   $3 = HEAP32[($2 + 4 | 0) >> 2] + 1 | 0;
   HEAP32[($2 + 4 | 0) >> 2] = $3;
  }
  if ($0 >>> 0 > 1644 >>> 0) {
   $lib_rt_pure_decrement($0 - 16 | 0)
  }
  return $1;
 }
 
 function $lib_util_sort_weakHeapSort_f64_($0, $1) {
  var $2 = 0, $3 = 0, $4 = 0.0, $5 = 0, $6 = 0.0, $7 = 0;
  $2 = (($1 + 31 | 0) >>> 5 | 0) << 2 | 0;
  $5 = $lib_rt_tlsf_allocateBlock($lib_rt_tlsf_maybeInitialize(), $2, 0) + 16 | 0;
  $lib_memory_memory_fill($5, $2);
  $3 = $1 - 1 | 0;
  for_loop_0 : while (1) {
   if (($3 | 0) > (0 | 0)) {
    $2 = $3;
    while_continue_1 : while (1) {
     if (($2 & 1 | 0 | 0) == ((HEAP32[((($2 >>> 6 | 0) << 2 | 0) + $5 | 0) >> 2] >>> (($2 >> 1 | 0) & 31 | 0) | 0) & 1 | 0 | 0)) {
      $2 = $2 >> 1 | 0;
      continue while_continue_1;
     }
     break while_continue_1;
    };
    $argumentsLength = 2;
    $2 = $2 >> 1 | 0;
    $4 = HEAPF64[(($2 << 3 | 0) + $0 | 0) >> 3];
    $6 = HEAPF64[(($3 << 3 | 0) + $0 | 0) >> 3];
    if ((FUNCTION_TABLE[HEAP32[1584 >> 2]]($4, $6) | 0 | 0) < (0 | 0)) {
     $7 = (($3 >>> 5 | 0) << 2 | 0) + $5 | 0;
     HEAP32[$7 >> 2] = HEAP32[$7 >> 2] ^ (1 << ($3 & 31 | 0) | 0) | 0;
     HEAPF64[(($3 << 3 | 0) + $0 | 0) >> 3] = $4;
     HEAPF64[(($2 << 3 | 0) + $0 | 0) >> 3] = $6;
    }
    $3 = $3 - 1 | 0;
    continue for_loop_0;
   }
   break for_loop_0;
  };
  $3 = $1 - 1 | 0;
  for_loop_2 : while (1) {
   if (($3 | 0) >= (2 | 0)) {
    $4 = HEAPF64[$0 >> 3];
    $1 = ($3 << 3 | 0) + $0 | 0;
    HEAPF64[$0 >> 3] = HEAPF64[$1 >> 3];
    HEAPF64[$1 >> 3] = $4;
    $1 = 1;
    while_continue_3 : while (1) {
     $2 = ((HEAP32[((($1 >>> 5 | 0) << 2 | 0) + $5 | 0) >> 2] >>> ($1 & 31 | 0) | 0) & 1 | 0) + ($1 << 1 | 0) | 0;
     if (($2 | 0) < ($3 | 0)) {
      $1 = $2;
      continue while_continue_3;
     }
     break while_continue_3;
    };
    while_continue_4 : while (1) {
     if (($1 | 0) > (0 | 0)) {
      $argumentsLength = 2;
      $4 = HEAPF64[$0 >> 3];
      $6 = HEAPF64[(($1 << 3 | 0) + $0 | 0) >> 3];
      if ((FUNCTION_TABLE[HEAP32[1584 >> 2]]($4, $6) | 0 | 0) < (0 | 0)) {
       $2 = (($1 >>> 5 | 0) << 2 | 0) + $5 | 0;
       $7 = HEAP32[$2 >> 2] ^ (1 << ($1 & 31 | 0) | 0) | 0;
       HEAP32[$2 >> 2] = $7;
       HEAPF64[(($1 << 3 | 0) + $0 | 0) >> 3] = $4;
       HEAPF64[$0 >> 3] = $6;
      }
      $1 = $1 >> 1 | 0;
      continue while_continue_4;
     }
     break while_continue_4;
    };
    $3 = $3 - 1 | 0;
    continue for_loop_2;
   }
   break for_loop_2;
  };
  $2 = $lib_rt_tlsf_maybeInitialize();
  $1 = $5 - 16 | 0;
  HEAP32[$1 >> 2] = HEAP32[$1 >> 2] | 1 | 0;
  $lib_rt_tlsf_insertBlock($2, $1);
  $4 = HEAPF64[($0 + 8 | 0) >> 3];
  HEAPF64[($0 + 8 | 0) >> 3] = HEAPF64[$0 >> 3];
  HEAPF64[$0 >> 3] = $4;
 }
 
 function $lib_typedarray_Float64Array_sort($0) {
  var $1 = 0, $2 = 0, $3 = 0, $4 = 0.0, $5 = 0.0, $6 = 0, $7 = 0;
  if ($0 >>> 0 > 1644 >>> 0) {
   $1 = $0 - 16 | 0;
   $7 = HEAP32[($1 + 4 | 0) >> 2] + 1 | 0;
   HEAP32[($1 + 4 | 0) >> 2] = $7;
  }
  $3 = HEAP32[($0 + 8 | 0) >> 2] >>> 3 | 0;
  $lib_typedarray_SORT__lib_typedarray_Float64Array_f64__inlined_0 : {
   if (($3 | 0) <= (1 | 0)) {
    break $lib_typedarray_SORT__lib_typedarray_Float64Array_f64__inlined_0
   }
   $2 = HEAP32[($0 + 4 | 0) >> 2];
   if (($3 | 0) == (2 | 0)) {
    $argumentsLength = 2;
    $4 = HEAPF64[($2 + 8 | 0) >> 3];
    $5 = HEAPF64[$2 >> 3];
    if ((FUNCTION_TABLE[HEAP32[1584 >> 2]]($4, $5) | 0 | 0) < (0 | 0)) {
     HEAPF64[($2 + 8 | 0) >> 3] = $5;
     HEAPF64[$2 >> 3] = $4;
    }
    break $lib_typedarray_SORT__lib_typedarray_Float64Array_f64__inlined_0;
   }
   if (($3 | 0) < (256 | 0)) {
    for_loop_0 : while (1) {
     if (($6 | 0) < ($3 | 0)) {
      $4 = HEAPF64[(($6 << 3 | 0) + $2 | 0) >> 3];
      $1 = $6 - 1 | 0;
      while_continue_1 : while (1) {
       if (($1 | 0) >= (0 | 0)) {
        while_break_1 : {
         $argumentsLength = 2;
         $5 = HEAPF64[(($1 << 3 | 0) + $2 | 0) >> 3];
         if ((FUNCTION_TABLE[HEAP32[1584 >> 2]]($4, $5) | 0 | 0) >= (0 | 0)) {
          break while_break_1
         }
         $7 = $1;
         $1 = $1 - 1 | 0;
         HEAPF64[((($7 + 1 | 0) << 3 | 0) + $2 | 0) >> 3] = $5;
         continue while_continue_1;
        }
       }
       break while_continue_1;
      };
      HEAPF64[((($1 + 1 | 0) << 3 | 0) + $2 | 0) >> 3] = $4;
      $6 = $6 + 1 | 0;
      continue for_loop_0;
     }
     break for_loop_0;
    }
   } else {
    $lib_util_sort_weakHeapSort_f64_($2, $3)
   }
  }
  return $0;
 }
 
 function $lib_util_sort_COMPARATOR_f64__anonymous_0($0, $1) {
  $0 = +$0;
  $1 = +$1;
  var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0;
  wasm2js_scratch_store_f64(+$0);
  $3 = wasm2js_scratch_load_i32(1 | 0) | 0;
  $2 = $3 >> 31 | 0;
  $8 = (wasm2js_scratch_load_i32(0 | 0) | 0) ^ (($2 & 1 | 0) << 31 | 0 | ($2 >>> 1 | 0) | 0) | 0;
  $9 = $8;
  $3 = ($2 >>> 1 | 0) ^ $3 | 0;
  wasm2js_scratch_store_f64(+$1);
  $6 = wasm2js_scratch_load_i32(1 | 0) | 0;
  $7 = wasm2js_scratch_load_i32(0 | 0) | 0;
  $2 = $6 >> 31 | 0;
  $4 = $2 >>> 1 | 0;
  $5 = (($2 & 1 | 0) << 31 | 0 | ($2 >>> 1 | 0) | 0) ^ $7 | 0;
  $2 = $5;
  $7 = $3;
  $4 = $6 ^ $4 | 0;
  $6 = $4;
  if (($3 | 0) > ($4 | 0)) {
   $5 = 1
  } else {
   $5 = ($7 | 0) >= ($6 | 0) ? $8 >>> 0 > $5 >>> 0 : 0
  }
  if (($3 | 0) < ($4 | 0)) {
   $2 = 1
  } else {
   $2 = ($3 | 0) <= ($4 | 0) ? $9 >>> 0 < $2 >>> 0 : 0
  }
  return $5 - $2 | 0 | 0;
 }
 
 function $lib_util_memory_memcpy($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0;
  while_continue_0 : while (1) {
   if ($2 ? $1 & 3 | 0 : 0) {
    $3 = $0;
    $0 = $0 + 1 | 0;
    $4 = $1;
    $1 = $1 + 1 | 0;
    HEAP8[$3 >> 0] = HEAPU8[$4 >> 0];
    $2 = $2 - 1 | 0;
    continue while_continue_0;
   }
   break while_continue_0;
  };
  if (!($0 & 3 | 0)) {
   while_continue_1 : while (1) {
    if ($2 >>> 0 >= 16 >>> 0) {
     HEAP32[$0 >> 2] = HEAP32[$1 >> 2];
     HEAP32[($0 + 4 | 0) >> 2] = HEAP32[($1 + 4 | 0) >> 2];
     HEAP32[($0 + 8 | 0) >> 2] = HEAP32[($1 + 8 | 0) >> 2];
     HEAP32[($0 + 12 | 0) >> 2] = HEAP32[($1 + 12 | 0) >> 2];
     $1 = $1 + 16 | 0;
     $0 = $0 + 16 | 0;
     $2 = $2 - 16 | 0;
     continue while_continue_1;
    }
    break while_continue_1;
   };
   if ($2 & 8 | 0) {
    HEAP32[$0 >> 2] = HEAP32[$1 >> 2];
    HEAP32[($0 + 4 | 0) >> 2] = HEAP32[($1 + 4 | 0) >> 2];
    $1 = $1 + 8 | 0;
    $0 = $0 + 8 | 0;
   }
   if ($2 & 4 | 0) {
    HEAP32[$0 >> 2] = HEAP32[$1 >> 2];
    $1 = $1 + 4 | 0;
    $0 = $0 + 4 | 0;
   }
   if ($2 & 2 | 0) {
    HEAP16[$0 >> 1] = HEAPU16[$1 >> 1];
    $1 = $1 + 2 | 0;
    $0 = $0 + 2 | 0;
   }
   if ($2 & 1 | 0) {
    HEAP8[$0 >> 0] = HEAPU8[$1 >> 0]
   }
   return;
  }
  if ($2 >>> 0 >= 32 >>> 0) {
   break_2 : {
    case2_2 : {
     switch (($0 & 3 | 0) - 1 | 0 | 0) {
     case 0:
      $5 = HEAP32[$1 >> 2];
      HEAP8[$0 >> 0] = HEAPU8[$1 >> 0];
      $3 = $0 + 1 | 0;
      $4 = $1 + 1 | 0;
      HEAP8[$3 >> 0] = HEAPU8[$4 >> 0];
      $0 = $3 + 2 | 0;
      $1 = $4 + 2 | 0;
      HEAP8[($3 + 1 | 0) >> 0] = HEAPU8[($4 + 1 | 0) >> 0];
      $2 = $2 - 3 | 0;
      while_continue_3 : while (1) {
       if ($2 >>> 0 >= 17 >>> 0) {
        $3 = HEAP32[($1 + 1 | 0) >> 2];
        HEAP32[$0 >> 2] = $3 << 8 | 0 | ($5 >>> 24 | 0) | 0;
        $4 = $3 >>> 24 | 0;
        $3 = HEAP32[($1 + 5 | 0) >> 2];
        HEAP32[($0 + 4 | 0) >> 2] = $4 | ($3 << 8 | 0) | 0;
        $4 = $3 >>> 24 | 0;
        $3 = HEAP32[($1 + 9 | 0) >> 2];
        HEAP32[($0 + 8 | 0) >> 2] = $4 | ($3 << 8 | 0) | 0;
        $5 = HEAP32[($1 + 13 | 0) >> 2];
        HEAP32[($0 + 12 | 0) >> 2] = $5 << 8 | 0 | ($3 >>> 24 | 0) | 0;
        $1 = $1 + 16 | 0;
        $0 = $0 + 16 | 0;
        $2 = $2 - 16 | 0;
        continue while_continue_3;
       }
       break while_continue_3;
      };
      break break_2;
     case 1:
      $5 = HEAP32[$1 >> 2];
      HEAP8[$0 >> 0] = HEAPU8[$1 >> 0];
      $3 = $0;
      $0 = $0 + 2 | 0;
      $4 = $1;
      $1 = $1 + 2 | 0;
      HEAP8[($3 + 1 | 0) >> 0] = HEAPU8[($4 + 1 | 0) >> 0];
      $2 = $2 - 2 | 0;
      while_continue_4 : while (1) {
       if ($2 >>> 0 >= 18 >>> 0) {
        $3 = HEAP32[($1 + 2 | 0) >> 2];
        HEAP32[$0 >> 2] = $3 << 16 | 0 | ($5 >>> 16 | 0) | 0;
        $4 = $3 >>> 16 | 0;
        $3 = HEAP32[($1 + 6 | 0) >> 2];
        HEAP32[($0 + 4 | 0) >> 2] = $4 | ($3 << 16 | 0) | 0;
        $4 = $3 >>> 16 | 0;
        $3 = HEAP32[($1 + 10 | 0) >> 2];
        HEAP32[($0 + 8 | 0) >> 2] = $4 | ($3 << 16 | 0) | 0;
        $5 = HEAP32[($1 + 14 | 0) >> 2];
        HEAP32[($0 + 12 | 0) >> 2] = $5 << 16 | 0 | ($3 >>> 16 | 0) | 0;
        $1 = $1 + 16 | 0;
        $0 = $0 + 16 | 0;
        $2 = $2 - 16 | 0;
        continue while_continue_4;
       }
       break while_continue_4;
      };
      break break_2;
     case 2:
      break case2_2;
     default:
      break break_2;
     };
    }
    $5 = HEAP32[$1 >> 2];
    $3 = $0;
    $0 = $0 + 1 | 0;
    $4 = $1;
    $1 = $1 + 1 | 0;
    HEAP8[$3 >> 0] = HEAPU8[$4 >> 0];
    $2 = $2 - 1 | 0;
    while_continue_5 : while (1) {
     if ($2 >>> 0 >= 19 >>> 0) {
      $3 = HEAP32[($1 + 3 | 0) >> 2];
      HEAP32[$0 >> 2] = $3 << 24 | 0 | ($5 >>> 8 | 0) | 0;
      $4 = $3 >>> 8 | 0;
      $3 = HEAP32[($1 + 7 | 0) >> 2];
      HEAP32[($0 + 4 | 0) >> 2] = $4 | ($3 << 24 | 0) | 0;
      $4 = $3 >>> 8 | 0;
      $3 = HEAP32[($1 + 11 | 0) >> 2];
      HEAP32[($0 + 8 | 0) >> 2] = $4 | ($3 << 24 | 0) | 0;
      $5 = HEAP32[($1 + 15 | 0) >> 2];
      HEAP32[($0 + 12 | 0) >> 2] = $5 << 24 | 0 | ($3 >>> 8 | 0) | 0;
      $1 = $1 + 16 | 0;
      $0 = $0 + 16 | 0;
      $2 = $2 - 16 | 0;
      continue while_continue_5;
     }
     break while_continue_5;
    };
   }
  }
  if ($2 & 16 | 0) {
   HEAP8[$0 >> 0] = HEAPU8[$1 >> 0];
   $0 = $0 + 1 | 0;
   $1 = $1 + 1 | 0;
   HEAP8[$0 >> 0] = HEAPU8[$1 >> 0];
   $0 = $0 + 1 | 0;
   $1 = $1 + 1 | 0;
   HEAP8[$0 >> 0] = HEAPU8[$1 >> 0];
   $0 = $0 + 1 | 0;
   $1 = $1 + 1 | 0;
   HEAP8[$0 >> 0] = HEAPU8[$1 >> 0];
   $0 = $0 + 1 | 0;
   $1 = $1 + 1 | 0;
   HEAP8[$0 >> 0] = HEAPU8[$1 >> 0];
   $0 = $0 + 1 | 0;
   $1 = $1 + 1 | 0;
   HEAP8[$0 >> 0] = HEAPU8[$1 >> 0];
   $0 = $0 + 1 | 0;
   $1 = $1 + 1 | 0;
   HEAP8[$0 >> 0] = HEAPU8[$1 >> 0];
   $0 = $0 + 1 | 0;
   $1 = $1 + 1 | 0;
   HEAP8[$0 >> 0] = HEAPU8[$1 >> 0];
   $0 = $0 + 1 | 0;
   $1 = $1 + 1 | 0;
   HEAP8[$0 >> 0] = HEAPU8[$1 >> 0];
   $0 = $0 + 1 | 0;
   $1 = $1 + 1 | 0;
   HEAP8[$0 >> 0] = HEAPU8[$1 >> 0];
   $0 = $0 + 1 | 0;
   $1 = $1 + 1 | 0;
   HEAP8[$0 >> 0] = HEAPU8[$1 >> 0];
   $0 = $0 + 1 | 0;
   $1 = $1 + 1 | 0;
   HEAP8[$0 >> 0] = HEAPU8[$1 >> 0];
   $0 = $0 + 1 | 0;
   $1 = $1 + 1 | 0;
   HEAP8[$0 >> 0] = HEAPU8[$1 >> 0];
   $0 = $0 + 1 | 0;
   $1 = $1 + 1 | 0;
   HEAP8[$0 >> 0] = HEAPU8[$1 >> 0];
   $0 = $0 + 1 | 0;
   $3 = $1 + 1 | 0;
   HEAP8[$0 >> 0] = HEAPU8[$3 >> 0];
   $1 = $3 + 2 | 0;
   HEAP8[($0 + 1 | 0) >> 0] = HEAPU8[($3 + 1 | 0) >> 0];
   $0 = $0 + 2 | 0;
  }
  if ($2 & 8 | 0) {
   HEAP8[$0 >> 0] = HEAPU8[$1 >> 0];
   $0 = $0 + 1 | 0;
   $1 = $1 + 1 | 0;
   HEAP8[$0 >> 0] = HEAPU8[$1 >> 0];
   $0 = $0 + 1 | 0;
   $1 = $1 + 1 | 0;
   HEAP8[$0 >> 0] = HEAPU8[$1 >> 0];
   $0 = $0 + 1 | 0;
   $1 = $1 + 1 | 0;
   HEAP8[$0 >> 0] = HEAPU8[$1 >> 0];
   $0 = $0 + 1 | 0;
   $1 = $1 + 1 | 0;
   HEAP8[$0 >> 0] = HEAPU8[$1 >> 0];
   $0 = $0 + 1 | 0;
   $1 = $1 + 1 | 0;
   HEAP8[$0 >> 0] = HEAPU8[$1 >> 0];
   $0 = $0 + 1 | 0;
   $3 = $1 + 1 | 0;
   HEAP8[$0 >> 0] = HEAPU8[$3 >> 0];
   $1 = $3 + 2 | 0;
   HEAP8[($0 + 1 | 0) >> 0] = HEAPU8[($3 + 1 | 0) >> 0];
   $0 = $0 + 2 | 0;
  }
  if ($2 & 4 | 0) {
   HEAP8[$0 >> 0] = HEAPU8[$1 >> 0];
   $0 = $0 + 1 | 0;
   $1 = $1 + 1 | 0;
   HEAP8[$0 >> 0] = HEAPU8[$1 >> 0];
   $0 = $0 + 1 | 0;
   $3 = $1 + 1 | 0;
   HEAP8[$0 >> 0] = HEAPU8[$3 >> 0];
   $1 = $3 + 2 | 0;
   HEAP8[($0 + 1 | 0) >> 0] = HEAPU8[($3 + 1 | 0) >> 0];
   $0 = $0 + 2 | 0;
  }
  if ($2 & 2 | 0) {
   HEAP8[$0 >> 0] = HEAPU8[$1 >> 0];
   $3 = $1;
   $1 = $1 + 2 | 0;
   HEAP8[($0 + 1 | 0) >> 0] = HEAPU8[($3 + 1 | 0) >> 0];
   $0 = $0 + 2 | 0;
  }
  if ($2 & 1 | 0) {
   HEAP8[$0 >> 0] = HEAPU8[$1 >> 0]
  }
 }
 
 function $lib_memory_memory_copy($0, $1, $2) {
  var $3 = 0, $4 = 0, $5 = 0;
  $lib_util_memory_memmove_inlined_0 : {
   $3 = $2;
   if (($0 | 0) == ($1 | 0)) {
    break $lib_util_memory_memmove_inlined_0
   }
   if ((($1 - $0 | 0) - $3 | 0) >>> 0 <= (0 - ($3 << 1 | 0) | 0) >>> 0) {
    $lib_util_memory_memcpy($0, $1, $3);
    break $lib_util_memory_memmove_inlined_0;
   }
   if ($0 >>> 0 < $1 >>> 0) {
    if (($1 & 7 | 0 | 0) == ($0 & 7 | 0 | 0)) {
     while_continue_0 : while (1) {
      if ($0 & 7 | 0) {
       if (!$3) {
        break $lib_util_memory_memmove_inlined_0
       }
       $3 = $3 - 1 | 0;
       $2 = $0;
       $0 = $0 + 1 | 0;
       $4 = $1;
       $1 = $1 + 1 | 0;
       HEAP8[$2 >> 0] = HEAPU8[$4 >> 0];
       continue while_continue_0;
      }
      break while_continue_0;
     };
     while_continue_1 : while (1) {
      if ($3 >>> 0 >= 8 >>> 0) {
       $2 = HEAP32[($1 + 4 | 0) >> 2];
       HEAP32[$0 >> 2] = HEAP32[$1 >> 2];
       HEAP32[($0 + 4 | 0) >> 2] = $2;
       $3 = $3 - 8 | 0;
       $0 = $0 + 8 | 0;
       $1 = $1 + 8 | 0;
       continue while_continue_1;
      }
      break while_continue_1;
     };
    }
    while_continue_2 : while (1) {
     if ($3) {
      $2 = $0;
      $0 = $0 + 1 | 0;
      $4 = $1;
      $1 = $1 + 1 | 0;
      HEAP8[$2 >> 0] = HEAPU8[$4 >> 0];
      $3 = $3 - 1 | 0;
      continue while_continue_2;
     }
     break while_continue_2;
    };
   } else {
    if (($1 & 7 | 0 | 0) == ($0 & 7 | 0 | 0)) {
     while_continue_3 : while (1) {
      if (($0 + $3 | 0) & 7 | 0) {
       if (!$3) {
        break $lib_util_memory_memmove_inlined_0
       }
       $3 = $3 - 1 | 0;
       $2 = $3 + $1 | 0;
       HEAP8[($0 + $3 | 0) >> 0] = HEAPU8[$2 >> 0];
       continue while_continue_3;
      }
      break while_continue_3;
     };
     while_continue_4 : while (1) {
      if ($3 >>> 0 >= 8 >>> 0) {
       $3 = $3 - 8 | 0;
       $2 = $3 + $1 | 0;
       $4 = HEAP32[($2 + 4 | 0) >> 2];
       $5 = $0 + $3 | 0;
       HEAP32[$5 >> 2] = HEAP32[$2 >> 2];
       HEAP32[($5 + 4 | 0) >> 2] = $4;
       continue while_continue_4;
      }
      break while_continue_4;
     };
    }
    while_continue_5 : while (1) {
     if ($3) {
      $3 = $3 - 1 | 0;
      $2 = $3 + $1 | 0;
      HEAP8[($0 + $3 | 0) >> 0] = HEAPU8[$2 >> 0];
      continue while_continue_5;
     }
     break while_continue_5;
    };
   }
  }
 }
 
 function $lib_typedarray_Float64Array_copyWithin($0, $1, $2, $3) {
  var $4 = 0, $5 = 0, $6 = 0, $7 = 0;
  if ($0 >>> 0 > 1644 >>> 0) {
   $6 = $0 - 16 | 0;
   $4 = HEAP32[($6 + 4 | 0) >> 2] + 1 | 0;
   HEAP32[($6 + 4 | 0) >> 2] = $4;
  }
  $6 = $0;
  $4 = HEAP32[($0 + 8 | 0) >> 2] >>> 3 | 0;
  $0 = ($3 | 0) < ($4 | 0);
  $5 = $0 ? $3 : $4;
  $3 = HEAP32[($6 + 4 | 0) >> 2];
  $7 = $3;
  if (($1 | 0) < (0 | 0)) {
   $0 = $1 + $4 | 0;
   $1 = ($0 | 0) > (0 | 0);
   $1 = $1 ? $0 : 0;
  } else {
   $1 = ($1 | 0) < ($4 | 0) ? $1 : $4
  }
  $7 = $7 + ($1 << 3 | 0) | 0;
  if (($2 | 0) < (0 | 0)) {
   $0 = $2 + $4 | 0;
   $2 = ($0 | 0) > (0 | 0);
   $0 = $2 ? $0 : 0;
  } else {
   $0 = ($2 | 0) < ($4 | 0) ? $2 : $4
  }
  $3 = ($0 << 3 | 0) + $3 | 0;
  if (($5 | 0) < (0 | 0)) {
   $2 = $4 + $5 | 0;
   $5 = ($2 | 0) > (0 | 0);
   $2 = $5 ? $2 : 0;
  } else {
   $2 = ($5 | 0) < ($4 | 0) ? $5 : $4
  }
  $0 = $2 - $0 | 0;
  $1 = $4 - $1 | 0;
  $2 = ($0 | 0) < ($1 | 0);
  $lib_memory_memory_copy($7, $3, ($2 ? $0 : $1) << 3 | 0);
  return $6;
 }
 
 function index_solveArcMoving() {
  var $0 = 0, $1 = 0, $2 = 0, $3 = 0.0, $4 = 0.0, $5 = 0.0, $6 = 0.0, $7 = 0.0, $8 = 0.0, $9 = 0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0, $14 = 0.0, $15 = 0.0;
  $1 = $lib_typedarray_Float64Array_fill(index_output);
  if ($1 >>> 0 > 1644 >>> 0) {
   $lib_rt_pure_decrement($1 - 16 | 0)
  }
  $0 = 6;
  $2 = index_input;
  $1 = HEAP32[($2 + 4 | 0) >> 2];
  $4 = HEAPF64[($1 + 40 | 0) >> 3];
  $5 = HEAPF64[($1 + 48 | 0) >> 3];
  $6 = HEAPF64[($1 + 56 | 0) >> 3];
  $3 = HEAPF64[($1 - -64 | 0) >> 3];
  $14 = HEAPF64[($1 + 72 | 0) >> 3];
  $10 = HEAPF64[($1 + 80 | 0) >> 3];
  $15 = HEAPF64[($1 + 88 | 0) >> 3];
  $11 = HEAPF64[($1 + 96 | 0) >> 3];
  $7 = HEAPF64[($1 + 104 | 0) >> 3];
  $12 = HEAPF64[($1 + 112 | 0) >> 3];
  $8 = -.5 * HEAPF64[($1 + 120 | 0) >> 3];
  HEAPF64[$1 >> 3] = $8 * $8;
  HEAPF64[(HEAP32[($2 + 4 | 0) >> 2] + 8 | 0) >> 3] = 2.0 * $7 * $8;
  $5 = $10 - $5;
  $10 = 2.0 * $5;
  HEAPF64[(HEAP32[($2 + 4 | 0) >> 2] + 16 | 0) >> 3] = $7 * $7 + $10 * $8 - $3 * $3 + $11 * $11 + $12 * $12;
  $4 = $14 - $4;
  $6 = $15 - $6;
  HEAPF64[(HEAP32[($2 + 4 | 0) >> 2] + 24 | 0) >> 3] = $10 * $7 + 2.0 * $4 * $11 + 2.0 * $6 * $12;
  HEAPF64[(HEAP32[($2 + 4 | 0) >> 2] + 32 | 0) >> 3] = $5 * $5 + $4 * $4 + $6 * $6;
  index_SolveQuartic();
  $1 = $lib_typedarray_Float64Array_subarray(index_output);
  $argumentsLength = 0;
  $2 = $lib_typedarray_Float64Array_sort($1);
  if ($2 >>> 0 > 1644 >>> 0) {
   $lib_rt_pure_decrement($2 - 16 | 0)
  }
  for_loop_0 : while (1) {
   if (($13 | 0) < (6 | 0) ? ($9 | 0) < (2 | 0) : 0) {
    $3 = HEAPF64[(HEAP32[(index_output + 4 | 0) >> 2] + ($13 << 3 | 0) | 0) >> 3];
    if (!($3 <= 0.0)) {
     $2 = index_output;
     HEAPF64[(HEAP32[($2 + 4 | 0) >> 2] + ($0 << 3 | 0) | 0) >> 3] = ($4 + $11 * $3) / $3;
     $0 = $0 + 1 | 0;
     HEAPF64[(HEAP32[($2 + 4 | 0) >> 2] + ($0 << 3 | 0) | 0) >> 3] = ($5 + $7 * $3 - $8 * $3 * $3) / $3;
     $0 = $0 + 1 | 0;
     HEAPF64[(HEAP32[($2 + 4 | 0) >> 2] + ($0 << 3 | 0) | 0) >> 3] = ($6 + $12 * $3) / $3;
     $9 = $9 + 1 | 0;
     $0 = $0 + 1 | 0;
    }
    $13 = $13 + 1 | 0;
    continue for_loop_0;
   }
   break for_loop_0;
  };
  if (($9 | 0) > (0 | 0)) {
   $2 = $lib_typedarray_Float64Array_copyWithin(index_output, $0 + 6 | 0, $0, $0 + 3 | 0);
   if ($2 >>> 0 > 1644 >>> 0) {
    $lib_rt_pure_decrement($2 - 16 | 0)
   }
  }
  if (($9 | 0) > (1 | 0)) {
   $0 = $lib_typedarray_Float64Array_copyWithin(index_output, $0 + 9 | 0, $0 + 3 | 0, $0 + 6 | 0);
   if ($0 >>> 0 > 1644 >>> 0) {
    $lib_rt_pure_decrement($0 - 16 | 0)
   }
  }
  $0 = $lib_typedarray_Float64Array_fill(index_input);
  if ($0 >>> 0 > 1644 >>> 0) {
   $lib_rt_pure_decrement($0 - 16 | 0)
  }
  if ($1 >>> 0 > 1644 >>> 0) {
   $lib_rt_pure_decrement($1 - 16 | 0)
  }
  return $9 | 0;
 }
 
 function index_solveLateralStatic() {
  var $0 = 0, $1 = 0.0, $2 = 0.0, $3 = 0.0, $4 = 0.0, $5 = 0.0, $6 = 0.0, $7 = 0.0, $8 = 0.0;
  $0 = $lib_typedarray_Float64Array_fill(index_output);
  if ($0 >>> 0 > 1644 >>> 0) {
   $lib_rt_pure_decrement($0 - 16 | 0)
  }
  $0 = HEAP32[(index_input + 4 | 0) >> 2];
  $6 = HEAPF64[($0 + 48 | 0) >> 3];
  $7 = HEAPF64[($0 + 72 | 0) >> 3];
  $5 = HEAPF64[($0 + 88 | 0) >> 3];
  $8 = HEAPF64[($0 + 96 | 0) >> 3];
  $1 = HEAPF64[($0 - -64 | 0) >> 3] - HEAPF64[($0 + 40 | 0) >> 3];
  $2 = HEAPF64[($0 + 80 | 0) >> 3] - HEAPF64[($0 + 56 | 0) >> 3];
  $3 = Math_sqrt($1 * $1 + $2 * $2);
  if ($3 == 0.0) {
   return 0 | 0
  }
  $3 = $3 / $5;
  $4 = $1 * $1 + $2 * $2;
  if ($4 > 0.0) {
   $4 = 1.0 / Math_sqrt($4);
   $1 = $1 * $4;
   $2 = $2 * $4;
  }
  $0 = index_output;
  HEAPF64[(HEAP32[($0 + 4 | 0) >> 2] + 48 | 0) >> 3] = $1 * $5;
  HEAPF64[(HEAP32[($0 + 4 | 0) >> 2] + 56 | 0) >> 3] = -(3.0 * $6 - 4.0 * $8 + $7) / $3;
  HEAPF64[(HEAP32[($0 + 4 | 0) >> 2] - -64 | 0) >> 3] = $2 * $5;
  HEAPF64[(HEAP32[($0 + 4 | 0) >> 2] + 72 | 0) >> 3] = -4.0 * ($6 - 2.0 * $8 + $7) / ($3 * $3);
  $0 = $lib_typedarray_Float64Array_fill(index_input);
  if ($0 >>> 0 > 1644 >>> 0) {
   $lib_rt_pure_decrement($0 - 16 | 0)
  }
  return 1 | 0;
 }
 
 function index_solveLateralMoving() {
  var $0 = 0, $1 = 0, $2 = 0.0, $3 = 0.0, $4 = 0.0, $5 = 0.0, $6 = 0.0, $7 = 0.0, $8 = 0.0, $9 = 0.0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0.0, $14 = 0.0, $15 = 0.0;
  $0 = $lib_typedarray_Float64Array_fill(index_output);
  if ($0 >>> 0 > 1644 >>> 0) {
   $lib_rt_pure_decrement($0 - 16 | 0)
  }
  $0 = index_input;
  $1 = HEAP32[($0 + 4 | 0) >> 2];
  $13 = HEAPF64[($1 + 40 | 0) >> 3];
  $12 = HEAPF64[($1 + 48 | 0) >> 3];
  $14 = HEAPF64[($1 + 56 | 0) >> 3];
  $4 = HEAPF64[($1 - -64 | 0) >> 3];
  $7 = HEAPF64[($1 + 72 | 0) >> 3];
  $5 = HEAPF64[($1 + 80 | 0) >> 3];
  $3 = HEAPF64[($1 + 104 | 0) >> 3];
  $15 = HEAPF64[($1 + 120 | 0) >> 3];
  $8 = HEAPF64[($1 + 96 | 0) >> 3];
  $9 = HEAPF64[($1 + 112 | 0) >> 3];
  $10 = HEAPF64[($1 + 88 | 0) >> 3];
  HEAPF64[$1 >> 3] = $8 * $8 + $9 * $9 - $10 * $10;
  $6 = $4 - $13;
  $2 = $5 - $14;
  HEAPF64[(HEAP32[($0 + 4 | 0) >> 2] + 8 | 0) >> 3] = 2.0 * $6 * $8 + $2 * $9;
  HEAPF64[(HEAP32[($0 + 4 | 0) >> 2] + 16 | 0) >> 3] = $6 * $6 + $2 * $2;
  $0 = index_SolveQuadric(0, 1);
  $1 = ($0 | 0) > (0 | 0);
  if ($1) {
   $1 = HEAPF64[HEAP32[(index_output + 4 | 0) >> 2] >> 3] > 0.0
  }
  $0 = ($0 | 0) > (1 | 0);
  if ($0) {
   $0 = HEAPF64[(HEAP32[(index_output + 4 | 0) >> 2] + 8 | 0) >> 3] > 0.0
  }
  if ($1 ? 0 : !$0) {
   return 0 | 0
  } else {
   if ($1 ? $0 : 0) {
    $0 = HEAP32[(index_output + 4 | 0) >> 2];
    $2 = Math_min(HEAPF64[$0 >> 3], HEAPF64[($0 + 8 | 0) >> 3]);
   } else {
    $2 = $1 ? HEAPF64[HEAP32[(index_output + 4 | 0) >> 2] >> 3] : HEAPF64[(HEAP32[(index_output + 4 | 0) >> 2] + 8 | 0) >> 3]
   }
  }
  $11 = $7 + $3 * $2;
  $6 = $4 + $8 * $2;
  $4 = $6 - $13;
  $7 = $5 + $9 * $2;
  $5 = $7 - $14;
  $3 = $4 * $4 + $5 * $5;
  if ($3 > 0.0) {
   $3 = 1.0 / Math_sqrt($3);
   $4 = $4 * $3;
   $5 = $5 * $3;
  }
  $0 = index_output;
  HEAPF64[(HEAP32[($0 + 4 | 0) >> 2] + 48 | 0) >> 3] = $4 * $10;
  $3 = Math_max($12, $11) + $15;
  HEAPF64[(HEAP32[($0 + 4 | 0) >> 2] + 56 | 0) >> 3] = -(3.0 * $12 - 4.0 * $3 + $11) / $2;
  HEAPF64[(HEAP32[($0 + 4 | 0) >> 2] - -64 | 0) >> 3] = $5 * $10;
  HEAPF64[(HEAP32[($0 + 4 | 0) >> 2] + 72 | 0) >> 3] = $6;
  HEAPF64[(HEAP32[($0 + 4 | 0) >> 2] + 80 | 0) >> 3] = $11;
  HEAPF64[(HEAP32[($0 + 4 | 0) >> 2] + 88 | 0) >> 3] = $7;
  HEAPF64[(HEAP32[($0 + 4 | 0) >> 2] + 96 | 0) >> 3] = -4.0 * ($12 - 2.0 * $3 + $11) / ($2 * $2);
  $0 = $lib_typedarray_Float64Array_fill(index_input);
  if ($0 >>> 0 > 1644 >>> 0) {
   $lib_rt_pure_decrement($0 - 16 | 0)
  }
  return 1 | 0;
 }
 
 function $start() {
  index_input = $lib_typedarray_Float64Array_constructor();
  index_output = $lib_typedarray_Float64Array_constructor();
 }
 
 function $lib_rt_pure___collect() {
  
 }
 
 function $lib_rt_pure_decrement($0) {
  var $1 = 0, $2 = 0;
  $1 = HEAP32[($0 + 4 | 0) >> 2];
  $2 = $1 & 268435455 | 0;
  if (($2 | 0) == (1 | 0)) {
   __inlined_func$_lib_rt___visit_members : {
    switch$1$default : {
     switch (HEAP32[($0 + 8 | 0) >> 2] | 0) {
     case 2:
     case 3:
      $1 = HEAP32[($0 + 16 | 0) >> 2];
      if ($1) {
       if ($1 >>> 0 >= 1644 >>> 0) {
        $lib_rt_pure_decrement($1 - 16 | 0)
       }
      }
      break __inlined_func$_lib_rt___visit_members;
     case 4:
      $1 = HEAP32[($0 + 20 | 0) >> 2];
      if ($1 >>> 0 >= 1644 >>> 0) {
       $lib_rt_pure_decrement($1 - 16 | 0)
      }
      break __inlined_func$_lib_rt___visit_members;
     case 0:
     case 1:
      break __inlined_func$_lib_rt___visit_members;
     default:
      break switch$1$default;
     };
    }
    abort();
   }
   HEAP32[$0 >> 2] = HEAP32[$0 >> 2] | 1 | 0;
   $lib_rt_tlsf_insertBlock($lib_rt_tlsf_ROOT, $0);
  } else {
   HEAP32[($0 + 4 | 0) >> 2] = $2 - 1 | 0 | ($1 & -268435456 | 0) | 0
  }
 }
 
 function index_SolveQuadric_varargs($0, $1) {
  $0 = $0 | 0;
  $1 = $1 | 0;
  $2of2 : {
   switch ($argumentsLength | 0) {
   default:
    abort();
   case 0:
    $0 = 0;
   case 1:
    $1 = 1;
    break;
   case 2:
    break $2of2;
   };
  }
  return index_SolveQuadric($0, $1) | 0;
 }
 
 function $setArgumentsLength($0) {
  $0 = $0 | 0;
  $argumentsLength = $0;
 }
 
 var FUNCTION_TABLE = [null, $lib_util_sort_COMPARATOR_f64__anonymous_0];
 $start();
 function __wasm_memory_size() {
  return buffer.byteLength / 65536 | 0;
 }
 
 function __wasm_memory_grow(pagesToAdd) {
  pagesToAdd = pagesToAdd | 0;
  var oldPages = __wasm_memory_size() | 0;
  var newPages = oldPages + pagesToAdd | 0;
  if ((oldPages < newPages) && (newPages < 65536)) {
   var newBuffer = new ArrayBuffer(Math_imul(newPages, 65536));
   var newHEAP8 = new global.Int8Array(newBuffer);
   newHEAP8.set(HEAP8);
   HEAP8 = newHEAP8;
   HEAP8 = new global.Int8Array(newBuffer);
   HEAP16 = new global.Int16Array(newBuffer);
   HEAP32 = new global.Int32Array(newBuffer);
   HEAPU8 = new global.Uint8Array(newBuffer);
   HEAPU16 = new global.Uint16Array(newBuffer);
   HEAPU32 = new global.Uint32Array(newBuffer);
   HEAPF32 = new global.Float32Array(newBuffer);
   HEAPF64 = new global.Float64Array(newBuffer);
   buffer = newBuffer;
  }
  return oldPages;
 }
 
 return {
  "memory": Object.create(Object.prototype, {
   "grow": {
    "value": __wasm_memory_grow
   }, 
   "buffer": {
    "get": function () {
     return buffer;
    }
    
   }
  }), 
  "__alloc": $lib_rt_tlsf___alloc, 
  "__retain": $lib_rt_pure___retain, 
  "__release": $lib_rt_pure___release, 
  "__collect": $lib_rt_pure___collect, 
  "getInputBufferPtr": index_getInputBufferPtr, 
  "getOutputBufferPtr": index_getOutputBufferPtr, 
  "SolveQuadric": index_SolveQuadric_varargs, 
  "SolveCubic": index_SolveCubic, 
  "SolveQuartic": index_SolveQuartic, 
  "range": index_range, 
  "solveArcStatic": index_solveArcStatic, 
  "solveArcMoving": index_solveArcMoving, 
  "solveLateralStatic": index_solveLateralStatic, 
  "solveLateralMoving": index_solveLateralMoving, 
  "__setArgumentsLength": $setArgumentsLength
 };
}

var memasmFunc = new ArrayBuffer(65536);
var bufferView = new Uint8Array(memasmFunc);
for (var base64ReverseLookup = new Uint8Array(123/*'z'+1*/), i = 25; i >= 0; --i) {
    base64ReverseLookup[48+i] = 52+i; // '0-9'
    base64ReverseLookup[65+i] = i; // 'A-Z'
    base64ReverseLookup[97+i] = 26+i; // 'a-z'
  }
  base64ReverseLookup[43] = 62; // '+'
  base64ReverseLookup[47] = 63; // '/'
  /** @noinline Inlining this function would mean expanding the base64 string 4x times in the source code, which Closure seems to be happy to do. */
  function base64DecodeToExistingUint8Array(uint8Array, offset, b64) {
    var b1, b2, i = 0, j = offset, bLength = b64.length, end = offset + (bLength*3>>2) - (b64[bLength-2] == '=') - (b64[bLength-1] == '=');
    for (; i < bLength; i += 4) {
      b1 = base64ReverseLookup[b64.charCodeAt(i+1)];
      b2 = base64ReverseLookup[b64.charCodeAt(i+2)];
      uint8Array[j++] = base64ReverseLookup[b64.charCodeAt(i)] << 2 | b1 >> 4;
      if (j < end) uint8Array[j++] = b1 << 4 | b2 >> 2;
      if (j < end) uint8Array[j++] = b2 << 6 | base64ReverseLookup[b64.charCodeAt(i+3)];
    } 
  }
  base64DecodeToExistingUint8Array(bufferView, 1024, "KAAAAAEAAAABAAAAKAAAAGEAbABsAG8AYwBhAHQAaQBvAG4AIAB0AG8AbwAgAGwAYQByAGcAZQ==");
base64DecodeToExistingUint8Array(bufferView, 1088, "HgAAAAEAAAABAAAAHgAAAH4AbABpAGIALwByAHQALwB0AGwAcwBmAC4AdABz");
base64DecodeToExistingUint8Array(bufferView, 1136, "HAAAAAEAAAABAAAAHAAAAEkAbgB2AGEAbABpAGQAIABsAGUAbgBnAHQAaA==");
base64DecodeToExistingUint8Array(bufferView, 1184, "JgAAAAEAAAABAAAAJgAAAH4AbABpAGIALwBhAHIAcgBhAHkAYgB1AGYAZgBlAHIALgB0AHM=");
base64DecodeToExistingUint8Array(bufferView, 1248, "JAAAAAEAAAABAAAAJAAAAEkAbgBkAGUAeAAgAG8AdQB0ACAAbwBmACAAcgBhAG4AZwBl");
base64DecodeToExistingUint8Array(bufferView, 1312, "JAAAAAEAAAABAAAAJAAAAH4AbABpAGIALwB0AHkAcABlAGQAYQByAHIAYQB5AC4AdABz");
base64DecodeToExistingUint8Array(bufferView, 1368, "boP5ogAAAADRVyf8KRVETpmVYtvA3TT1q2NR/kGQQzw6biS3YcW73uouSQbg0k1CHOsd/hyS0Qn1NYLoPqcpsSZwnOmERLsuOdaROUF+X7SLX4Sc9DlTg/+X+B87KPm9ixEv7w+YBd7PfjZtH20KWmY/Rk+3Ccsnx7ondS3qX573OQc9e/Hl67Ff+2vqklKKRjADVghdjR8gvM/wq2t7/GGR46kdNvSaX4WZZQgb5l6A2P+NQGigFFcVBgYxJ3NN");
base64DecodeToExistingUint8Array(bufferView, 1568, "CAAAAAEAAAAEAAAACAAAAAE=");
base64DecodeToExistingUint8Array(bufferView, 1600, "BQAAACAAAAAAAAAAIAAAAAAAAAAgAAAAAAAAACEaAAACAAAAIA==");
var retasmFunc = asmFunc({Math,Int8Array,Uint8Array,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,NaN,Infinity}, {abort:function() { throw new Error('abort'); },abort},memasmFunc);
export var memory = retasmFunc.memory;
export var __alloc = retasmFunc.__alloc;
export var __retain = retasmFunc.__retain;
export var __release = retasmFunc.__release;
export var __collect = retasmFunc.__collect;
export var getInputBufferPtr = retasmFunc.getInputBufferPtr;
export var getOutputBufferPtr = retasmFunc.getOutputBufferPtr;
export var SolveQuadric = retasmFunc.SolveQuadric;
export var SolveCubic = retasmFunc.SolveCubic;
export var SolveQuartic = retasmFunc.SolveQuartic;
export var range = retasmFunc.range;
export var solveArcStatic = retasmFunc.solveArcStatic;
export var solveArcMoving = retasmFunc.solveArcMoving;
export var solveLateralStatic = retasmFunc.solveLateralStatic;
export var solveLateralMoving = retasmFunc.solveLateralMoving;
export var __setArgumentsLength = retasmFunc.__setArgumentsLength;
